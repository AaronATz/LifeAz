/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, HostListener } from '@angular/core';
import * as elementResizeDetectorMaker from 'element-resize-detector';
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
var EllipsisDirective = /** @class */ (function () {
    /**
     * The directive's constructor
     */
    function EllipsisDirective(elementRef, renderer, ngZone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Whether the ellipsis should be applied on window resize
         */
        this.applyOnWindowResize = false;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from innerHTML
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         *  If anything is passed, the ellipsisCharacters will be
         *  wrapped in <a></a> tags and an event handler for the
         *  passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param  max      Highest possible number
     * @param  callback Should return true as long as the passed number is valid
     * @return          Largest possible number
     */
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    EllipsisDirective.numericBinarySearch = /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    function (max, callback) {
        /** @type {?} */
        var low = 0;
        /** @type {?} */
        var high = max;
        /** @type {?} */
        var best = -1;
        /** @type {?} */
        var mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            /** @type {?} */
            var result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    };
    /**
     * Escape html special characters
     * @param unsafe string potentially containing special characters
     * @return       escaped string
     */
    /**
     * Escape html special characters
     * @param {?} unsafe string potentially containing special characters
     * @return {?} escaped string
     */
    EllipsisDirective.escapeHtml = /**
     * Escape html special characters
     * @param {?} unsafe string potentially containing special characters
     * @return {?} escaped string
     */
    function (unsafe) {
        if (unsafe === undefined || unsafe === null) {
            return '';
        }
        return String(unsafe)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    };
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     */
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    EllipsisDirective.prototype.ngAfterViewInit = /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    function () {
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        if (this.moreClickEmitter.observers.length > 0) {
            this.ellipsisCharacters = "<a href=\"#\" class=\"ngx-ellipsis-more\">" + this.ellipsisCharacters + "</a>";
        }
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (this.ellipsisContent) {
            this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
        }
        else if (!this.originalText) {
            this.originalText = this.elem.innerText;
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        /** @type {?} */
        var text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    };
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     */
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    EllipsisDirective.prototype.ngOnChanges = /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    function () {
        if (!this.elem
            || typeof this.ellipsisContent === 'undefined'
            || this.originalText === EllipsisDirective.escapeHtml(this.ellipsisContent)) {
            return;
        }
        this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
        this.applyEllipsis();
    };
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     */
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    EllipsisDirective.prototype.ngOnDestroy = /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    function () {
        this.removeAllListeners();
    };
    /**
     * remove all resize listeners
     */
    /**
     * remove all resize listeners
     * @return {?}
     */
    EllipsisDirective.prototype.removeAllListeners = /**
     * remove all resize listeners
     * @return {?}
     */
    function () {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    };
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param triggerNow=false if true, the ellipsis is applied immediately
     */
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    EllipsisDirective.prototype.addResizeListener = /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    function (triggerNow) {
        if (triggerNow === void 0) { triggerNow = false; }
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'window':
                this.applyOnWindowResize = true;
                if (triggerNow) {
                    this.applyEllipsis();
                }
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn("No such ellipsis-resize-detection strategy: '" + this.resizeDetectionStrategy + "'. Using 'element-resize-detector' instead");
                }
            // tslint:disable-next-line:no-switch-case-fall-through
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    EllipsisDirective.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.ngZone.run(function () {
            if (_this.applyOnWindowResize) {
                _this.applyEllipsis();
            }
        });
    };
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param scrollStrategy=true Use the default elementResizeDetector's - strategy - s. https://github.com/wnr/element-resize-detector
     */
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    EllipsisDirective.prototype.addElementResizeListener = /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    function (scrollStrategy) {
        var _this = this;
        if (scrollStrategy === void 0) { scrollStrategy = true; }
        if (!EllipsisDirective.elementResizeDetector) {
            /** @type {?} */
            var maker = elementResizeDetectorMaker;
            EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        /** @type {?} */
        var calledAsynchronously = false;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, function () {
            if (!calledAsynchronously) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                return;
            }
            _this.applyEllipsis();
        });
        calledAsynchronously = true;
    };
    /**
     * Stop listening for any resize event.
     */
    /**
     * Stop listening for any resize event.
     * @return {?}
     */
    EllipsisDirective.prototype.removeResizeListener = /**
     * Stop listening for any resize event.
     * @return {?}
     */
    function () {
        if (this.resizeDetectionStrategy !== 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.applyOnWindowResize = false;
        }
    };
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param max the maximum length the text may have
     * @return string       the truncated string
     */
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    EllipsisDirective.prototype.getTruncatedText = /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    function (max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        /** @type {?} */
        var truncatedText = this.originalText.substr(0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText + this.ellipsisCharacters;
        }
        /** @type {?} */
        var i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return truncatedText.substr(0, i) + this.ellipsisCharacters;
    };
    /**
     * Set the truncated text to be displayed in the inner div
     * @param max the maximum length the text may have
     * @param addMoreListener=false listen for click on the ellipsisCharacters if the text has been truncated
     */
    /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    EllipsisDirective.prototype.truncateText = /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    function (max, addMoreListener) {
        var _this = this;
        if (addMoreListener === void 0) { addMoreListener = false; }
        /** @type {?} */
        var text = this.getTruncatedText(max);
        this.renderer.setProperty(this.innerElem, 'innerHTML', text);
        if (!addMoreListener) {
            return;
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        // If the text has been truncated, add a more click listener:
        if (text !== this.originalText) {
            this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', function (e) {
                if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                _this.moreClickEmitter.emit(e);
            });
        }
    };
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     */
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    EllipsisDirective.prototype.applyEllipsis = /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    function () {
        var _this = this;
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        // Find the best length by trial and error:
        /** @type {?} */
        var maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, function (curLength) {
            _this.truncateText(curLength);
            return !_this.isOverflowing;
        });
        // Apply the best length:
        this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
        // Re-attach the resize listener:
        this.addResizeListener();
    };
    Object.defineProperty(EllipsisDirective.prototype, "isOverflowing", {
        /**
         * Whether the text is exceeding the element's boundaries or not
         */
        get: /**
         * Whether the text is exceeding the element's boundaries or not
         * @return {?}
         */
        function () {
            // Enforce hidden overflow (required to compare client width/height with scroll width/height)
            /** @type {?} */
            var currentOverflow = this.elem.style.overflow;
            if (!currentOverflow || currentOverflow === 'visible') {
                this.elem.style.overflow = 'hidden';
            }
            /** @type {?} */
            var isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
            // Reset overflow to the original configuration:
            this.elem.style.overflow = currentOverflow;
            return isOverflowing;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Instance of https://github.com/wnr/element-resize-detector
     */
    EllipsisDirective.elementResizeDetector = null;
    EllipsisDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ellipsis]'
                },] }
    ];
    /** @nocollapse */
    EllipsisDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    EllipsisDirective.propDecorators = {
        ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
        ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
        ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
        resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
        moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return EllipsisDirective;
}());
export { EllipsisDirective };
if (false) {
    /**
     * Instance of https://github.com/wnr/element-resize-detector
     * @type {?}
     */
    EllipsisDirective.elementResizeDetector;
    /**
     * The original text (not truncated yet)
     * @type {?}
     */
    EllipsisDirective.prototype.originalText;
    /**
     * The referenced element
     * @type {?}
     */
    EllipsisDirective.prototype.elem;
    /**
     * Inner div element (will be auto-created)
     * @type {?}
     */
    EllipsisDirective.prototype.innerElem;
    /**
     * Whether the ellipsis should be applied on window resize
     * @type {?}
     */
    EllipsisDirective.prototype.applyOnWindowResize;
    /**
     * Remove function for the currently registered click listener
     * on the link `this.ellipsisCharacters` are wrapped in.
     * @type {?}
     */
    EllipsisDirective.prototype.destroyMoreClickListener;
    /**
     * The ellipsis html attribute
     * If anything is passed, this will be used as a string to append to
     * the truncated contents.
     * Else '...' will be appended.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisCharacters;
    /**
     * The ellipsis-content html attribute
     * If passed this is used as content, else contents
     * are fetched from innerHTML
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisContent;
    /**
     * The ellipsis-word-boundaries html attribute
     * If anything is passed, each character will be interpreted
     * as a word boundary at which the text may be truncated.
     * Else the text may be truncated at any character.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisWordBoundaries;
    /**
     * The ellipsis-resize-detection html attribute
     * Algorithm to use to detect element/window resize - any of the following:
     * 'element-resize-detector': (default) Use https://github.com/wnr/element-resize-detector with its 'scroll' strategy
     * 'element-resize-detector-object': Use https://github.com/wnr/element-resize-detector with its 'object' strategy (deprecated)
     * 'window': Only check if the whole window has been resized/changed orientation by using angular's built-in HostListener
     * @type {?}
     */
    EllipsisDirective.prototype.resizeDetectionStrategy;
    /**
     * The ellipsis-click-more html attribute
     *  If anything is passed, the ellipsisCharacters will be
     *  wrapped in <a></a> tags and an event handler for the
     *  passed function will be added to the link
     * @type {?}
     */
    EllipsisDirective.prototype.moreClickEmitter;
    /** @type {?} */
    EllipsisDirective.prototype.elementRef;
    /** @type {?} */
    EllipsisDirective.prototype.renderer;
    /** @type {?} */
    EllipsisDirective.prototype.ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxsaXBzaXMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWVsbGlwc2lzLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osTUFBTSxFQUNOLFlBQVksRUFJYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEtBQUssMEJBQTBCLE1BQU0seUJBQXlCLENBQUM7Ozs7O0FBTXRFO0lBMEhFOztPQUVHO0lBQ0gsMkJBQTJCLFVBQXNCLEVBQVUsUUFBbUIsRUFBVSxNQUFjO1FBQTNFLGVBQVUsR0FBVixVQUFVLENBQVk7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBUTs7OztRQWxHOUYsd0JBQW1CLEdBQUcsS0FBSyxDQUFDOzs7Ozs7UUFxQlQsb0JBQWUsR0FBVyxJQUFJLENBQUM7Ozs7Ozs7UUF5QjNCLHFCQUFnQixHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO0lBb0RrQixDQUFDO0lBakQzRzs7Ozs7O09BTUc7Ozs7Ozs7O0lBQ1kscUNBQW1COzs7Ozs7O0lBQWxDLFVBQW1DLEdBQVcsRUFBRSxRQUFnQzs7WUFDMUUsR0FBRyxHQUFHLENBQUM7O1lBQ1AsSUFBSSxHQUFHLEdBQUc7O1lBQ1YsSUFBSSxHQUFHLENBQUMsQ0FBQzs7WUFDVCxHQUFXO1FBRWYsT0FBTyxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ2xCLHNDQUFzQztZQUN0QyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7O2dCQUNyQixNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQztZQUM1QixJQUFJLENBQUMsTUFBTSxFQUFFO2dC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U0FBQztvQkFDVCxRQUFRLEVBQUUsWUFBWTtpQkFDdkI7Ozs7Z0JBbkJDLFVBQVU7Z0JBQ1YsU0FBUztnQkFJVCxNQUFNOzs7cUNBcURMLEtBQUssU0FBQyxVQUFVO2tDQU9oQixLQUFLLFNBQUMsa0JBQWtCO3lDQVF4QixLQUFLLFNBQUMsMEJBQTBCOzBDQVNoQyxLQUFLLFNBQUMsMkJBQTJCO21DQVFqQyxNQUFNLFNBQUMscUJBQXFCOzJCQW9LNUIsWUFBWSxTQUFDLGVBQWUsRUFBRSxDQUFDLFFBQVEsQ0FBQzs7SUF3STNDLHdCQUFDO0NBQUEsQUFyWEQsSUFxWEM7U0FsWFksaUJBQWlCOzs7Ozs7SUFJNUIsd0NBQTRFOzs7OztJQUs1RSx5Q0FBNkI7Ozs7O0lBSzdCLGlDQUFrQjs7Ozs7SUFLbEIsc0NBQXVCOzs7OztJQUt2QixnREFBb0M7Ozs7OztJQU1wQyxxREFBNkM7Ozs7Ozs7O0lBUTdDLCtDQUE4Qzs7Ozs7OztJQU85Qyw0Q0FBMEQ7Ozs7Ozs7O0lBUTFELG1EQUFrRTs7Ozs7Ozs7O0lBU2xFLG9EQUEwSTs7Ozs7Ozs7SUFRMUksNkNBQXdGOztJQW9EckUsdUNBQThCOztJQUFFLHFDQUEyQjs7SUFBRSxtQ0FBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIFJlbmRlcmVyMixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBOZ1pvbmUsXG4gIEhvc3RMaXN0ZW5lcixcbiAgT25DaGFuZ2VzLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlciBmcm9tICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIHRydW5jYXRlIHRoZSBjb250YWluZWQgdGV4dCwgaWYgaXQgZXhjZWVkcyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXNcbiAqIGFuZCBhcHBlbmQgY2hhcmFjdGVycyAoY29uZmlndXJhYmxlLCBkZWZhdWx0ICcuLi4nKSBpZiBzby5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2VsbGlwc2lzXSdcbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBlbGVtZW50UmVzaXplRGV0ZWN0b3I6IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyLkVyZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCB0ZXh0IChub3QgdHJ1bmNhdGVkIHlldClcbiAgICovXG4gIHByaXZhdGUgb3JpZ2luYWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZlcmVuY2VkIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBJbm5lciBkaXYgZWxlbWVudCAod2lsbCBiZSBhdXRvLWNyZWF0ZWQpXG4gICAqL1xuICBwcml2YXRlIGlubmVyRWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGxpcHNpcyBzaG91bGQgYmUgYXBwbGllZCBvbiB3aW5kb3cgcmVzaXplXG4gICAqL1xuICBwcml2YXRlIGFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcblxuICAvKipcbiAgICogUmVtb3ZlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgY2xpY2sgbGlzdGVuZXJcbiAgICogb24gdGhlIGxpbmsgYHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzYCBhcmUgd3JhcHBlZCBpbi5cbiAgICovXG4gIHByaXZhdGUgZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCB0aGlzIHdpbGwgYmUgdXNlZCBhcyBhIHN0cmluZyB0byBhcHBlbmQgdG9cbiAgICogdGhlIHRydW5jYXRlZCBjb250ZW50cy5cbiAgICogRWxzZSAnLi4uJyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcycpIGVsbGlwc2lzQ2hhcmFjdGVyczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtY29udGVudCBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBwYXNzZWQgdGhpcyBpcyB1c2VkIGFzIGNvbnRlbnQsIGVsc2UgY29udGVudHNcbiAgICogYXJlIGZldGNoZWQgZnJvbSBpbm5lckhUTUxcbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtY29udGVudCcpIGVsbGlwc2lzQ29udGVudDogc3RyaW5nID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLXdvcmQtYm91bmRhcmllcyBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIGVhY2ggY2hhcmFjdGVyIHdpbGwgYmUgaW50ZXJwcmV0ZWRcbiAgICogYXMgYSB3b3JkIGJvdW5kYXJ5IGF0IHdoaWNoIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQuXG4gICAqIEVsc2UgdGhlIHRleHQgbWF5IGJlIHRydW5jYXRlZCBhdCBhbnkgY2hhcmFjdGVyLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMnKSBlbGxpcHNpc1dvcmRCb3VuZGFyaWVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIGh0bWwgYXR0cmlidXRlXG4gICAqIEFsZ29yaXRobSB0byB1c2UgdG8gZGV0ZWN0IGVsZW1lbnQvd2luZG93IHJlc2l6ZSAtIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOiAoZGVmYXVsdCkgVXNlIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Igd2l0aCBpdHMgJ3Njcm9sbCcgc3RyYXRlZ3lcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6IFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdvYmplY3QnIHN0cmF0ZWd5IChkZXByZWNhdGVkKVxuICAgKiAnd2luZG93JzogT25seSBjaGVjayBpZiB0aGUgd2hvbGUgd2luZG93IGhhcyBiZWVuIHJlc2l6ZWQvY2hhbmdlZCBvcmllbnRhdGlvbiBieSB1c2luZyBhbmd1bGFyJ3MgYnVpbHQtaW4gSG9zdExpc3RlbmVyXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24nKSByZXNpemVEZXRlY3Rpb25TdHJhdGVneTogJycgfCAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCcgfCAnd2luZG93JztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNsaWNrLW1vcmUgaHRtbCBhdHRyaWJ1dGVcbiAgICogIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlXG4gICAqICB3cmFwcGVkIGluIDxhPjwvYT4gdGFncyBhbmQgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlXG4gICAqICBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlua1xuICAgKi9cbiAgQE91dHB1dCgnZWxsaXBzaXMtY2xpY2stbW9yZScpIG1vcmVDbGlja0VtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHRvIHF1aWNrbHkgZmluZCB0aGUgbGFyZ2VzdCBudW1iZXIgZm9yXG4gICAqIHdoaWNoIGBjYWxsYmFjayhudW1iZXIpYCBzdGlsbCByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSAgbWF4ICAgICAgSGlnaGVzdCBwb3NzaWJsZSBudW1iZXJcbiAgICogQHBhcmFtICBjYWxsYmFjayBTaG91bGQgcmV0dXJuIHRydWUgYXMgbG9uZyBhcyB0aGUgcGFzc2VkIG51bWJlciBpcyB2YWxpZFxuICAgKiBAcmV0dXJuICAgICAgICAgIExhcmdlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBudW1lcmljQmluYXJ5U2VhcmNoKG1heDogbnVtYmVyLCBjYWxsYmFjazogKG46IG51bWJlcikgPT4gYm9vbGVhbik6IG51bWJlciB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBtYXg7XG4gICAgbGV0IGJlc3QgPSAtMTtcbiAgICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICBtaWQgPSB+figobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKG1pZCk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlc3QgPSBtaWQ7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlIGh0bWwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSB1bnNhZmUgc3RyaW5nIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAqIEByZXR1cm4gICAgICAgZXNjYXBlZCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGVzY2FwZUh0bWwodW5zYWZlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICh1bnNhZmUgPT09IHVuZGVmaW5lZCB8fCB1bnNhZmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKHVuc2FmZSlcbiAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7Jyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgaW5pdCB2aWV3IGxpZmUgY3ljbGUgaG9vay5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGVsZW1lbnQgZm9yIGRpc3BsYXlpbmcgdGhlIGVsbGlwc2lzLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIGxldCB0aGUgZWxsaXBzaXMgY2hhcmFjdGVycyBkZWZhdWx0IHRvICcuLi4nOlxuICAgIGlmICh0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9PT0gJycpIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gJy4uLic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPSBgPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm5neC1lbGxpcHNpcy1tb3JlXCI+JHt0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc308L2E+YDtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHJlZ2V4IHJlcGxhY2Ugb24gd29yZCBib3VuZGFyaWVzOlxuICAgIGlmICghdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPSAnJztcbiAgICB9XG4gICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJ1snICsgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpICsgJ10nO1xuXG4gICAgLy8gc3RvcmUgdGhlIG9yaWdpbmFsIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50OlxuICAgIHRoaXMuZWxlbSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGlmICh0aGlzLmVsbGlwc2lzQ29udGVudCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSBFbGxpcHNpc0RpcmVjdGl2ZS5lc2NhcGVIdG1sKHRoaXMuZWxsaXBzaXNDb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsZW0uaW5uZXJUZXh0O1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHdyYXBwZXIgZGl2IChyZXF1aXJlZCBmb3IgcmVzaXplIGV2ZW50cyB0byB3b3JrIHByb3Blcmx5KTpcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbSwgJ2lubmVySFRNTCcsICcnKTtcbiAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmlubmVyRWxlbSwgJ25neC1lbGxpcHNpcy1pbm5lcicpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZVRleHQodGhpcy5vcmlnaW5hbFRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0sIHRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtLCB0aGlzLmlubmVyRWxlbSk7XG5cbiAgICAvLyBzdGFydCBsaXN0ZW5pbmcgZm9yIHJlc2l6ZSBldmVudHM6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcih0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgY2hhbmdlIGxpZmUgY3ljbGUgaG9vay5cbiAgICogQ2hhbmdlIG9yaWdpbmFsIHRleHQgKGlmIHRoZSBlbGxpcHNpcy1jb250ZW50IGhhcyBiZWVuIHBhc3NlZClcbiAgICogYW5kIHJlLXJlbmRlclxuICAgKi9cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1cbiAgICAgIHx8IHR5cGVvZiB0aGlzLmVsbGlwc2lzQ29udGVudCA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgIHx8IHRoaXMub3JpZ2luYWxUZXh0ID09PSBFbGxpcHNpc0RpcmVjdGl2ZS5lc2NhcGVIdG1sKHRoaXMuZWxsaXBzaXNDb250ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gRWxsaXBzaXNEaXJlY3RpdmUuZXNjYXBlSHRtbCh0aGlzLmVsbGlwc2lzQ29udGVudCk7XG4gICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGRlc3Ryb3kgbGlmZSBjeWNsZSBob29rLlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBhbGwgcmVzaXplIGxpc3RlbmVyc1xuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlUmVzaXplTGlzdGVuZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBjYWxsIGFwcGx5RWxsaXBzaXMoKSB3aGVuZXZlciBhIHJlc2l6ZSBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXIgKHdpbmRvdy9lbGVtZW50KSBkZXBlbmRzIG9uIHRoZSByZXNpemVEZXRlY3Rpb25TdHJhdGVneS5cbiAgICogQHBhcmFtIHRyaWdnZXJOb3c9ZmFsc2UgaWYgdHJ1ZSwgdGhlIGVsbGlwc2lzIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHlcbiAgICovXG4gIHByaXZhdGUgYWRkUmVzaXplTGlzdGVuZXIodHJpZ2dlck5vdyA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ID0gJyc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICB0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUgPSB0cnVlO1xuICAgICAgICBpZiAodHJpZ2dlck5vdykge1xuICAgICAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Itb2JqZWN0JzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnNvbGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBObyBzdWNoIGVsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24gc3RyYXRlZ3k6ICcke3RoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3l9Jy4gVXNpbmcgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJyBpbnN0ZWFkYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zd2l0Y2gtY2FzZS1mYWxsLXRocm91Z2hcbiAgICAgIGNhc2UgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzpcbiAgICAgIGNhc2UgJyc6XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnLCBbJyRldmVudCddKSBvblJlc2l6ZShldmVudDogRXZlbnQpIHtcbiAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgdGhlIGVsZW1lbnRcbiAgICogaGFzIGJlZW4gcmVzaXplZC5cbiAgICogQHBhcmFtIHNjcm9sbFN0cmF0ZWd5PXRydWUgVXNlIHRoZSBkZWZhdWx0IGVsZW1lbnRSZXNpemVEZXRlY3RvcidzIC0gc3RyYXRlZ3kgLSBzLiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIGFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcihzY3JvbGxTdHJhdGVneSA9IHRydWUpIHtcbiAgICBpZiAoIUVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvcikge1xuICAgICAgY29uc3QgbWFrZXI6IGFueSA9IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyO1xuICAgICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yID0gbWFrZXIoeyBzdHJhdGVneTogc2Nyb2xsU3RyYXRlZ3kgPyAnc2Nyb2xsJyA6ICdvYmplY3QnIH0pO1xuICAgIH1cblxuXG4gICAgbGV0IGNhbGxlZEFzeW5jaHJvbm91c2x5ID0gZmFsc2U7XG4gICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yLmxpc3RlblRvKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAoKSA9PiB7XG4gICAgICBpZiAoIWNhbGxlZEFzeW5jaHJvbm91c2x5KSB7XG4gICAgICAgIC8vIGVsZW1lbnRSZXNpemVEZXRlY3RvciBmaXJlcyB0aGUgZXZlbnQgZGlyZWN0bHkgYWZ0ZXIgcmUtYXR0YWNoaW5nIHRoZSBsaXN0ZW5lclxuICAgICAgICAvLyAtPiBkaXNjYXJkIHRoYXQgZmlyc3QgZXZlbnQ6XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgIH0pO1xuICAgIGNhbGxlZEFzeW5jaHJvbm91c2x5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYW55IHJlc2l6ZSBldmVudC5cbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlUmVzaXplTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kgIT09ICd3aW5kb3cnKSB7XG4gICAgICBpZiAoRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yICYmIHRoaXMuZWxlbSkge1xuICAgICAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IucmVtb3ZlQWxsTGlzdGVuZXJzKHRoaXMuZWxlbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbmFsIHRleHQncyB0cnVuY2F0ZWQgdmVyc2lvbi4gSWYgdGhlIHRleHQgcmVhbGx5IG5lZWRlZCB0b1xuICAgKiBiZSB0cnVuY2F0ZWQsIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEByZXR1cm4gc3RyaW5nICAgICAgIHRoZSB0cnVuY2F0ZWQgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIGdldFRydW5jYXRlZFRleHQobWF4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5vcmlnaW5hbFRleHQgfHwgdGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoIDw9IG1heCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxUZXh0O1xuICAgIH1cblxuICAgIGNvbnN0IHRydW5jYXRlZFRleHQgPSB0aGlzLm9yaWdpbmFsVGV4dC5zdWJzdHIoMCwgbWF4KTtcbiAgICBpZiAodGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID09PSAnW10nIHx8IHRoaXMub3JpZ2luYWxUZXh0LmNoYXJBdChtYXgpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIHJldHVybiB0cnVuY2F0ZWRUZXh0ICsgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgbGV0IGkgPSBtYXggLSAxO1xuICAgIHdoaWxlIChpID4gMCAmJiAhdHJ1bmNhdGVkVGV4dC5jaGFyQXQoaSkubWF0Y2godGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSkge1xuICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dC5zdWJzdHIoMCwgaSkgKyB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRydW5jYXRlZCB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5uZXIgZGl2XG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEBwYXJhbSBhZGRNb3JlTGlzdGVuZXI9ZmFsc2UgbGlzdGVuIGZvciBjbGljayBvbiB0aGUgZWxsaXBzaXNDaGFyYWN0ZXJzIGlmIHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZFxuICAgKi9cbiAgcHJpdmF0ZSB0cnVuY2F0ZVRleHQobWF4OiBudW1iZXIsIGFkZE1vcmVMaXN0ZW5lciA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMuZ2V0VHJ1bmNhdGVkVGV4dChtYXgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbm5lckVsZW0sICdpbm5lckhUTUwnLCB0ZXh0KTtcblxuICAgIGlmICghYWRkTW9yZUxpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBtb3JlIGNsaWNrIGxpc3RlbmVyOlxuICAgIGlmICh0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGV4dCBoYXMgYmVlbiB0cnVuY2F0ZWQsIGFkZCBhIG1vcmUgY2xpY2sgbGlzdGVuZXI6XG4gICAgaWYgKHRleHQgIT09IHRoaXMub3JpZ2luYWxUZXh0KSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuaW5uZXJFbGVtLCAnY2xpY2snLCAoZTogYW55KSA9PiB7XG4gICAgICAgIGlmICghZS50YXJnZXQgfHwgZS50YXJnZXQuY2xhc3NOYW1lICE9PSAnbmd4LWVsbGlwc2lzLW1vcmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5tb3JlQ2xpY2tFbWl0dGVyLmVtaXQoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSBlbGxpcHNpcyBpbiB0aGUgaW5uZXIgZGl2IGlmIHRoZSB0ZXh0IHdvdWxkIGV4Y2VlZCB0aGUgYm91bmRhcmllc1xuICAgKi9cbiAgcHJpdmF0ZSBhcHBseUVsbGlwc2lzKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgcmVzaXplIGxpc3RlbmVyIGFzIGNoYW5naW5nIHRoZSBjb250YWluZWQgdGV4dCB3b3VsZCB0cmlnZ2VyIGV2ZW50czpcbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKCk7XG5cbiAgICAvLyBGaW5kIHRoZSBiZXN0IGxlbmd0aCBieSB0cmlhbCBhbmQgZXJyb3I6XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gRWxsaXBzaXNEaXJlY3RpdmUubnVtZXJpY0JpbmFyeVNlYXJjaCh0aGlzLm9yaWdpbmFsVGV4dC5sZW5ndGgsIGN1ckxlbmd0aCA9PiB7XG4gICAgICB0aGlzLnRydW5jYXRlVGV4dChjdXJMZW5ndGgpO1xuICAgICAgcmV0dXJuICF0aGlzLmlzT3ZlcmZsb3dpbmc7XG4gICAgfSk7XG5cbiAgICAvLyBBcHBseSB0aGUgYmVzdCBsZW5ndGg6XG4gICAgdGhpcy50cnVuY2F0ZVRleHQobWF4TGVuZ3RoLCAodGhpcy5tb3JlQ2xpY2tFbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwKSk7XG5cbiAgICAvLyBSZS1hdHRhY2ggdGhlIHJlc2l6ZSBsaXN0ZW5lcjpcbiAgICB0aGlzLmFkZFJlc2l6ZUxpc3RlbmVyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0ZXh0IGlzIGV4Y2VlZGluZyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXMgb3Igbm90XG4gICAqL1xuICBwcml2YXRlIGdldCBpc092ZXJmbG93aW5nKCk6IGJvb2xlYW4ge1xuICAgIC8vIEVuZm9yY2UgaGlkZGVuIG92ZXJmbG93IChyZXF1aXJlZCB0byBjb21wYXJlIGNsaWVudCB3aWR0aC9oZWlnaHQgd2l0aCBzY3JvbGwgd2lkdGgvaGVpZ2h0KVxuICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvdyA9IHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdztcbiAgICBpZiAoIWN1cnJlbnRPdmVyZmxvdyB8fCBjdXJyZW50T3ZlcmZsb3cgPT09ICd2aXNpYmxlJykge1xuICAgICAgdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgY29uc3QgaXNPdmVyZmxvd2luZyA9IHRoaXMuZWxlbS5jbGllbnRXaWR0aCA8IHRoaXMuZWxlbS5zY3JvbGxXaWR0aCAtIDEgfHwgdGhpcy5lbGVtLmNsaWVudEhlaWdodCA8IHRoaXMuZWxlbS5zY3JvbGxIZWlnaHQgLSAxO1xuXG4gICAgLy8gUmVzZXQgb3ZlcmZsb3cgdG8gdGhlIG9yaWdpbmFsIGNvbmZpZ3VyYXRpb246XG4gICAgdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93ID0gY3VycmVudE92ZXJmbG93O1xuXG4gICAgcmV0dXJuIGlzT3ZlcmZsb3dpbmc7XG4gIH1cbn1cbiJdfQ==