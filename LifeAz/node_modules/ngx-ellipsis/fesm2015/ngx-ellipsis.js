import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, HostListener, NgModule } from '@angular/core';
import * as elementResizeDetectorMaker from 'element-resize-detector';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
class EllipsisDirective {
    /**
     * The directive's constructor
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(elementRef, renderer, ngZone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Whether the ellipsis should be applied on window resize
         */
        this.applyOnWindowResize = false;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from innerHTML
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         *  If anything is passed, the ellipsisCharacters will be
         *  wrapped in <a></a> tags and an event handler for the
         *  passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    static numericBinarySearch(max, callback) {
        /** @type {?} */
        let low = 0;
        /** @type {?} */
        let high = max;
        /** @type {?} */
        let best = -1;
        /** @type {?} */
        let mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            /** @type {?} */
            const result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    }
    /**
     * Escape html special characters
     * @param {?} unsafe string potentially containing special characters
     * @return {?} escaped string
     */
    static escapeHtml(unsafe) {
        if (unsafe === undefined || unsafe === null) {
            return '';
        }
        return String(unsafe)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    ngAfterViewInit() {
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        if (this.moreClickEmitter.observers.length > 0) {
            this.ellipsisCharacters = `<a href="#" class="ngx-ellipsis-more">${this.ellipsisCharacters}</a>`;
        }
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (this.ellipsisContent) {
            this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
        }
        else if (!this.originalText) {
            this.originalText = this.elem.innerText;
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        /** @type {?} */
        const text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    }
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    ngOnChanges() {
        if (!this.elem
            || typeof this.ellipsisContent === 'undefined'
            || this.originalText === EllipsisDirective.escapeHtml(this.ellipsisContent)) {
            return;
        }
        this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
        this.applyEllipsis();
    }
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    ngOnDestroy() {
        this.removeAllListeners();
    }
    /**
     * remove all resize listeners
     * @return {?}
     */
    removeAllListeners() {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    addResizeListener(triggerNow = false) {
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'window':
                this.applyOnWindowResize = true;
                if (triggerNow) {
                    this.applyEllipsis();
                }
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn(`No such ellipsis-resize-detection strategy: '${this.resizeDetectionStrategy}'. Using 'element-resize-detector' instead`);
                }
            // tslint:disable-next-line:no-switch-case-fall-through
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.ngZone.run(() => {
            if (this.applyOnWindowResize) {
                this.applyEllipsis();
            }
        });
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    addElementResizeListener(scrollStrategy = true) {
        if (!EllipsisDirective.elementResizeDetector) {
            /** @type {?} */
            const maker = elementResizeDetectorMaker;
            EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        /** @type {?} */
        let calledAsynchronously = false;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, () => {
            if (!calledAsynchronously) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                return;
            }
            this.applyEllipsis();
        });
        calledAsynchronously = true;
    }
    /**
     * Stop listening for any resize event.
     * @return {?}
     */
    removeResizeListener() {
        if (this.resizeDetectionStrategy !== 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.applyOnWindowResize = false;
        }
    }
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    getTruncatedText(max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        /** @type {?} */
        const truncatedText = this.originalText.substr(0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText + this.ellipsisCharacters;
        }
        /** @type {?} */
        let i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return truncatedText.substr(0, i) + this.ellipsisCharacters;
    }
    /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    truncateText(max, addMoreListener = false) {
        /** @type {?} */
        const text = this.getTruncatedText(max);
        this.renderer.setProperty(this.innerElem, 'innerHTML', text);
        if (!addMoreListener) {
            return;
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        // If the text has been truncated, add a more click listener:
        if (text !== this.originalText) {
            this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', (e) => {
                if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                this.moreClickEmitter.emit(e);
            });
        }
    }
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    applyEllipsis() {
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        // Find the best length by trial and error:
        /** @type {?} */
        const maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, curLength => {
            this.truncateText(curLength);
            return !this.isOverflowing;
        });
        // Apply the best length:
        this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
        // Re-attach the resize listener:
        this.addResizeListener();
    }
    /**
     * Whether the text is exceeding the element's boundaries or not
     * @return {?}
     */
    get isOverflowing() {
        // Enforce hidden overflow (required to compare client width/height with scroll width/height)
        /** @type {?} */
        const currentOverflow = this.elem.style.overflow;
        if (!currentOverflow || currentOverflow === 'visible') {
            this.elem.style.overflow = 'hidden';
        }
        /** @type {?} */
        const isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
        // Reset overflow to the original configuration:
        this.elem.style.overflow = currentOverflow;
        return isOverflowing;
    }
}
/**
 * Instance of https://github.com/wnr/element-resize-detector
 */
EllipsisDirective.elementResizeDetector = null;
EllipsisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ellipsis]'
            },] }
];
/** @nocollapse */
EllipsisDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
EllipsisDirective.propDecorators = {
    ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
    ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
    ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
    resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
    moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class EllipsisModule {
}
EllipsisModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [EllipsisDirective],
                exports: [EllipsisDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { EllipsisDirective, EllipsisModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWVsbGlwc2lzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtZWxsaXBzaXMvbGliL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtZWxsaXBzaXMvbGliL2VsbGlwc2lzLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIFJlbmRlcmVyMixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBOZ1pvbmUsXG4gIEhvc3RMaXN0ZW5lcixcbiAgT25DaGFuZ2VzLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlciBmcm9tICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIHRydW5jYXRlIHRoZSBjb250YWluZWQgdGV4dCwgaWYgaXQgZXhjZWVkcyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXNcbiAqIGFuZCBhcHBlbmQgY2hhcmFjdGVycyAoY29uZmlndXJhYmxlLCBkZWZhdWx0ICcuLi4nKSBpZiBzby5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2VsbGlwc2lzXSdcbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBlbGVtZW50UmVzaXplRGV0ZWN0b3I6IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyLkVyZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCB0ZXh0IChub3QgdHJ1bmNhdGVkIHlldClcbiAgICovXG4gIHByaXZhdGUgb3JpZ2luYWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZlcmVuY2VkIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBJbm5lciBkaXYgZWxlbWVudCAod2lsbCBiZSBhdXRvLWNyZWF0ZWQpXG4gICAqL1xuICBwcml2YXRlIGlubmVyRWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGxpcHNpcyBzaG91bGQgYmUgYXBwbGllZCBvbiB3aW5kb3cgcmVzaXplXG4gICAqL1xuICBwcml2YXRlIGFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcblxuICAvKipcbiAgICogUmVtb3ZlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgY2xpY2sgbGlzdGVuZXJcbiAgICogb24gdGhlIGxpbmsgYHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzYCBhcmUgd3JhcHBlZCBpbi5cbiAgICovXG4gIHByaXZhdGUgZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCB0aGlzIHdpbGwgYmUgdXNlZCBhcyBhIHN0cmluZyB0byBhcHBlbmQgdG9cbiAgICogdGhlIHRydW5jYXRlZCBjb250ZW50cy5cbiAgICogRWxzZSAnLi4uJyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcycpIGVsbGlwc2lzQ2hhcmFjdGVyczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtY29udGVudCBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBwYXNzZWQgdGhpcyBpcyB1c2VkIGFzIGNvbnRlbnQsIGVsc2UgY29udGVudHNcbiAgICogYXJlIGZldGNoZWQgZnJvbSBpbm5lckhUTUxcbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtY29udGVudCcpIGVsbGlwc2lzQ29udGVudDogc3RyaW5nID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLXdvcmQtYm91bmRhcmllcyBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIGVhY2ggY2hhcmFjdGVyIHdpbGwgYmUgaW50ZXJwcmV0ZWRcbiAgICogYXMgYSB3b3JkIGJvdW5kYXJ5IGF0IHdoaWNoIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQuXG4gICAqIEVsc2UgdGhlIHRleHQgbWF5IGJlIHRydW5jYXRlZCBhdCBhbnkgY2hhcmFjdGVyLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMnKSBlbGxpcHNpc1dvcmRCb3VuZGFyaWVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIGh0bWwgYXR0cmlidXRlXG4gICAqIEFsZ29yaXRobSB0byB1c2UgdG8gZGV0ZWN0IGVsZW1lbnQvd2luZG93IHJlc2l6ZSAtIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOiAoZGVmYXVsdCkgVXNlIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Igd2l0aCBpdHMgJ3Njcm9sbCcgc3RyYXRlZ3lcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6IFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdvYmplY3QnIHN0cmF0ZWd5IChkZXByZWNhdGVkKVxuICAgKiAnd2luZG93JzogT25seSBjaGVjayBpZiB0aGUgd2hvbGUgd2luZG93IGhhcyBiZWVuIHJlc2l6ZWQvY2hhbmdlZCBvcmllbnRhdGlvbiBieSB1c2luZyBhbmd1bGFyJ3MgYnVpbHQtaW4gSG9zdExpc3RlbmVyXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24nKSByZXNpemVEZXRlY3Rpb25TdHJhdGVneTogJycgfCAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCcgfCAnd2luZG93JztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNsaWNrLW1vcmUgaHRtbCBhdHRyaWJ1dGVcbiAgICogIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlXG4gICAqICB3cmFwcGVkIGluIDxhPjwvYT4gdGFncyBhbmQgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlXG4gICAqICBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlua1xuICAgKi9cbiAgQE91dHB1dCgnZWxsaXBzaXMtY2xpY2stbW9yZScpIG1vcmVDbGlja0VtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHRvIHF1aWNrbHkgZmluZCB0aGUgbGFyZ2VzdCBudW1iZXIgZm9yXG4gICAqIHdoaWNoIGBjYWxsYmFjayhudW1iZXIpYCBzdGlsbCByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSAgbWF4ICAgICAgSGlnaGVzdCBwb3NzaWJsZSBudW1iZXJcbiAgICogQHBhcmFtICBjYWxsYmFjayBTaG91bGQgcmV0dXJuIHRydWUgYXMgbG9uZyBhcyB0aGUgcGFzc2VkIG51bWJlciBpcyB2YWxpZFxuICAgKiBAcmV0dXJuICAgICAgICAgIExhcmdlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBudW1lcmljQmluYXJ5U2VhcmNoKG1heDogbnVtYmVyLCBjYWxsYmFjazogKG46IG51bWJlcikgPT4gYm9vbGVhbik6IG51bWJlciB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBtYXg7XG4gICAgbGV0IGJlc3QgPSAtMTtcbiAgICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICBtaWQgPSB+figobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKG1pZCk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlc3QgPSBtaWQ7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlIGh0bWwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSB1bnNhZmUgc3RyaW5nIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAqIEByZXR1cm4gICAgICAgZXNjYXBlZCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGVzY2FwZUh0bWwodW5zYWZlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICh1bnNhZmUgPT09IHVuZGVmaW5lZCB8fCB1bnNhZmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKHVuc2FmZSlcbiAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7Jyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgaW5pdCB2aWV3IGxpZmUgY3ljbGUgaG9vay5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGVsZW1lbnQgZm9yIGRpc3BsYXlpbmcgdGhlIGVsbGlwc2lzLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIGxldCB0aGUgZWxsaXBzaXMgY2hhcmFjdGVycyBkZWZhdWx0IHRvICcuLi4nOlxuICAgIGlmICh0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9PT0gJycpIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gJy4uLic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPSBgPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm5neC1lbGxpcHNpcy1tb3JlXCI+JHt0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc308L2E+YDtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHJlZ2V4IHJlcGxhY2Ugb24gd29yZCBib3VuZGFyaWVzOlxuICAgIGlmICghdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPSAnJztcbiAgICB9XG4gICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJ1snICsgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpICsgJ10nO1xuXG4gICAgLy8gc3RvcmUgdGhlIG9yaWdpbmFsIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50OlxuICAgIHRoaXMuZWxlbSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGlmICh0aGlzLmVsbGlwc2lzQ29udGVudCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSBFbGxpcHNpc0RpcmVjdGl2ZS5lc2NhcGVIdG1sKHRoaXMuZWxsaXBzaXNDb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsZW0uaW5uZXJUZXh0O1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHdyYXBwZXIgZGl2IChyZXF1aXJlZCBmb3IgcmVzaXplIGV2ZW50cyB0byB3b3JrIHByb3Blcmx5KTpcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbSwgJ2lubmVySFRNTCcsICcnKTtcbiAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmlubmVyRWxlbSwgJ25neC1lbGxpcHNpcy1pbm5lcicpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZVRleHQodGhpcy5vcmlnaW5hbFRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0sIHRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtLCB0aGlzLmlubmVyRWxlbSk7XG5cbiAgICAvLyBzdGFydCBsaXN0ZW5pbmcgZm9yIHJlc2l6ZSBldmVudHM6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcih0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgY2hhbmdlIGxpZmUgY3ljbGUgaG9vay5cbiAgICogQ2hhbmdlIG9yaWdpbmFsIHRleHQgKGlmIHRoZSBlbGxpcHNpcy1jb250ZW50IGhhcyBiZWVuIHBhc3NlZClcbiAgICogYW5kIHJlLXJlbmRlclxuICAgKi9cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1cbiAgICAgIHx8IHR5cGVvZiB0aGlzLmVsbGlwc2lzQ29udGVudCA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgIHx8IHRoaXMub3JpZ2luYWxUZXh0ID09PSBFbGxpcHNpc0RpcmVjdGl2ZS5lc2NhcGVIdG1sKHRoaXMuZWxsaXBzaXNDb250ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gRWxsaXBzaXNEaXJlY3RpdmUuZXNjYXBlSHRtbCh0aGlzLmVsbGlwc2lzQ29udGVudCk7XG4gICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGRlc3Ryb3kgbGlmZSBjeWNsZSBob29rLlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBhbGwgcmVzaXplIGxpc3RlbmVyc1xuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlUmVzaXplTGlzdGVuZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBjYWxsIGFwcGx5RWxsaXBzaXMoKSB3aGVuZXZlciBhIHJlc2l6ZSBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXIgKHdpbmRvdy9lbGVtZW50KSBkZXBlbmRzIG9uIHRoZSByZXNpemVEZXRlY3Rpb25TdHJhdGVneS5cbiAgICogQHBhcmFtIHRyaWdnZXJOb3c9ZmFsc2UgaWYgdHJ1ZSwgdGhlIGVsbGlwc2lzIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHlcbiAgICovXG4gIHByaXZhdGUgYWRkUmVzaXplTGlzdGVuZXIodHJpZ2dlck5vdyA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ID0gJyc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICB0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUgPSB0cnVlO1xuICAgICAgICBpZiAodHJpZ2dlck5vdykge1xuICAgICAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Itb2JqZWN0JzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnNvbGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBObyBzdWNoIGVsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24gc3RyYXRlZ3k6ICcke3RoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3l9Jy4gVXNpbmcgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJyBpbnN0ZWFkYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zd2l0Y2gtY2FzZS1mYWxsLXRocm91Z2hcbiAgICAgIGNhc2UgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzpcbiAgICAgIGNhc2UgJyc6XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnLCBbJyRldmVudCddKSBvblJlc2l6ZShldmVudDogRXZlbnQpIHtcbiAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgdGhlIGVsZW1lbnRcbiAgICogaGFzIGJlZW4gcmVzaXplZC5cbiAgICogQHBhcmFtIHNjcm9sbFN0cmF0ZWd5PXRydWUgVXNlIHRoZSBkZWZhdWx0IGVsZW1lbnRSZXNpemVEZXRlY3RvcidzIC0gc3RyYXRlZ3kgLSBzLiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIGFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcihzY3JvbGxTdHJhdGVneSA9IHRydWUpIHtcbiAgICBpZiAoIUVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvcikge1xuICAgICAgY29uc3QgbWFrZXI6IGFueSA9IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyO1xuICAgICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yID0gbWFrZXIoeyBzdHJhdGVneTogc2Nyb2xsU3RyYXRlZ3kgPyAnc2Nyb2xsJyA6ICdvYmplY3QnIH0pO1xuICAgIH1cblxuXG4gICAgbGV0IGNhbGxlZEFzeW5jaHJvbm91c2x5ID0gZmFsc2U7XG4gICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yLmxpc3RlblRvKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAoKSA9PiB7XG4gICAgICBpZiAoIWNhbGxlZEFzeW5jaHJvbm91c2x5KSB7XG4gICAgICAgIC8vIGVsZW1lbnRSZXNpemVEZXRlY3RvciBmaXJlcyB0aGUgZXZlbnQgZGlyZWN0bHkgYWZ0ZXIgcmUtYXR0YWNoaW5nIHRoZSBsaXN0ZW5lclxuICAgICAgICAvLyAtPiBkaXNjYXJkIHRoYXQgZmlyc3QgZXZlbnQ6XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgIH0pO1xuICAgIGNhbGxlZEFzeW5jaHJvbm91c2x5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYW55IHJlc2l6ZSBldmVudC5cbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlUmVzaXplTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kgIT09ICd3aW5kb3cnKSB7XG4gICAgICBpZiAoRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yICYmIHRoaXMuZWxlbSkge1xuICAgICAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IucmVtb3ZlQWxsTGlzdGVuZXJzKHRoaXMuZWxlbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbmFsIHRleHQncyB0cnVuY2F0ZWQgdmVyc2lvbi4gSWYgdGhlIHRleHQgcmVhbGx5IG5lZWRlZCB0b1xuICAgKiBiZSB0cnVuY2F0ZWQsIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEByZXR1cm4gc3RyaW5nICAgICAgIHRoZSB0cnVuY2F0ZWQgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIGdldFRydW5jYXRlZFRleHQobWF4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5vcmlnaW5hbFRleHQgfHwgdGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoIDw9IG1heCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxUZXh0O1xuICAgIH1cblxuICAgIGNvbnN0IHRydW5jYXRlZFRleHQgPSB0aGlzLm9yaWdpbmFsVGV4dC5zdWJzdHIoMCwgbWF4KTtcbiAgICBpZiAodGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID09PSAnW10nIHx8IHRoaXMub3JpZ2luYWxUZXh0LmNoYXJBdChtYXgpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIHJldHVybiB0cnVuY2F0ZWRUZXh0ICsgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgbGV0IGkgPSBtYXggLSAxO1xuICAgIHdoaWxlIChpID4gMCAmJiAhdHJ1bmNhdGVkVGV4dC5jaGFyQXQoaSkubWF0Y2godGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSkge1xuICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dC5zdWJzdHIoMCwgaSkgKyB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRydW5jYXRlZCB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5uZXIgZGl2XG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEBwYXJhbSBhZGRNb3JlTGlzdGVuZXI9ZmFsc2UgbGlzdGVuIGZvciBjbGljayBvbiB0aGUgZWxsaXBzaXNDaGFyYWN0ZXJzIGlmIHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZFxuICAgKi9cbiAgcHJpdmF0ZSB0cnVuY2F0ZVRleHQobWF4OiBudW1iZXIsIGFkZE1vcmVMaXN0ZW5lciA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMuZ2V0VHJ1bmNhdGVkVGV4dChtYXgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbm5lckVsZW0sICdpbm5lckhUTUwnLCB0ZXh0KTtcblxuICAgIGlmICghYWRkTW9yZUxpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBtb3JlIGNsaWNrIGxpc3RlbmVyOlxuICAgIGlmICh0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGV4dCBoYXMgYmVlbiB0cnVuY2F0ZWQsIGFkZCBhIG1vcmUgY2xpY2sgbGlzdGVuZXI6XG4gICAgaWYgKHRleHQgIT09IHRoaXMub3JpZ2luYWxUZXh0KSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuaW5uZXJFbGVtLCAnY2xpY2snLCAoZTogYW55KSA9PiB7XG4gICAgICAgIGlmICghZS50YXJnZXQgfHwgZS50YXJnZXQuY2xhc3NOYW1lICE9PSAnbmd4LWVsbGlwc2lzLW1vcmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5tb3JlQ2xpY2tFbWl0dGVyLmVtaXQoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSBlbGxpcHNpcyBpbiB0aGUgaW5uZXIgZGl2IGlmIHRoZSB0ZXh0IHdvdWxkIGV4Y2VlZCB0aGUgYm91bmRhcmllc1xuICAgKi9cbiAgcHJpdmF0ZSBhcHBseUVsbGlwc2lzKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgcmVzaXplIGxpc3RlbmVyIGFzIGNoYW5naW5nIHRoZSBjb250YWluZWQgdGV4dCB3b3VsZCB0cmlnZ2VyIGV2ZW50czpcbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKCk7XG5cbiAgICAvLyBGaW5kIHRoZSBiZXN0IGxlbmd0aCBieSB0cmlhbCBhbmQgZXJyb3I6XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gRWxsaXBzaXNEaXJlY3RpdmUubnVtZXJpY0JpbmFyeVNlYXJjaCh0aGlzLm9yaWdpbmFsVGV4dC5sZW5ndGgsIGN1ckxlbmd0aCA9PiB7XG4gICAgICB0aGlzLnRydW5jYXRlVGV4dChjdXJMZW5ndGgpO1xuICAgICAgcmV0dXJuICF0aGlzLmlzT3ZlcmZsb3dpbmc7XG4gICAgfSk7XG5cbiAgICAvLyBBcHBseSB0aGUgYmVzdCBsZW5ndGg6XG4gICAgdGhpcy50cnVuY2F0ZVRleHQobWF4TGVuZ3RoLCAodGhpcy5tb3JlQ2xpY2tFbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwKSk7XG5cbiAgICAvLyBSZS1hdHRhY2ggdGhlIHJlc2l6ZSBsaXN0ZW5lcjpcbiAgICB0aGlzLmFkZFJlc2l6ZUxpc3RlbmVyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0ZXh0IGlzIGV4Y2VlZGluZyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXMgb3Igbm90XG4gICAqL1xuICBwcml2YXRlIGdldCBpc092ZXJmbG93aW5nKCk6IGJvb2xlYW4ge1xuICAgIC8vIEVuZm9yY2UgaGlkZGVuIG92ZXJmbG93IChyZXF1aXJlZCB0byBjb21wYXJlIGNsaWVudCB3aWR0aC9oZWlnaHQgd2l0aCBzY3JvbGwgd2lkdGgvaGVpZ2h0KVxuICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvdyA9IHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdztcbiAgICBpZiAoIWN1cnJlbnRPdmVyZmxvdyB8fCBjdXJyZW50T3ZlcmZsb3cgPT09ICd2aXNpYmxlJykge1xuICAgICAgdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgY29uc3QgaXNPdmVyZmxvd2luZyA9IHRoaXMuZWxlbS5jbGllbnRXaWR0aCA8IHRoaXMuZWxlbS5zY3JvbGxXaWR0aCAtIDEgfHwgdGhpcy5lbGVtLmNsaWVudEhlaWdodCA8IHRoaXMuZWxlbS5zY3JvbGxIZWlnaHQgLSAxO1xuXG4gICAgLy8gUmVzZXQgb3ZlcmZsb3cgdG8gdGhlIG9yaWdpbmFsIGNvbmZpZ3VyYXRpb246XG4gICAgdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93ID0gY3VycmVudE92ZXJmbG93O1xuXG4gICAgcmV0dXJuIGlzT3ZlcmZsb3dpbmc7XG4gIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBFbGxpcHNpc0RpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy9lbGxpcHNpcy5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW0VsbGlwc2lzRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW0VsbGlwc2lzRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBFbGxpcHNpc01vZHVsZSB7IH1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFzQkEsTUFBYSxpQkFBaUI7Ozs7Ozs7SUEwSDVCLFlBQTJCLFVBQXNCLEVBQVUsUUFBbUIsRUFBVSxNQUFjO1FBQTNFLGVBQVUsR0FBVixVQUFVLENBQVk7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBUTs7OztRQWxHOUYsd0JBQW1CLEdBQUcsS0FBSyxDQUFDOzs7Ozs7UUFxQlQsb0JBQWUsR0FBVyxJQUFJLENBQUM7Ozs7Ozs7UUF5QjNCLHFCQUFnQixHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO0tBb0RtQjs7Ozs7Ozs7SUExQ25HLE9BQU8sbUJBQW1CLENBQUMsR0FBVyxFQUFFLFFBQWdDOztZ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