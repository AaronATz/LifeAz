/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Renderer2, Input, Output, EventEmitter, NgZone, HostListener } from '@angular/core';
import * as elementResizeDetectorMaker from 'element-resize-detector';
/**
 * Directive to truncate the contained text, if it exceeds the element's boundaries
 * and append characters (configurable, default '...') if so.
 */
export class EllipsisDirective {
    /**
     * The directive's constructor
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(elementRef, renderer, ngZone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /**
         * Whether the ellipsis should be applied on window resize
         */
        this.applyOnWindowResize = false;
        /**
         * The ellipsis-content html attribute
         * If passed this is used as content, else contents
         * are fetched from innerHTML
         */
        this.ellipsisContent = null;
        /**
         * The ellipsis-click-more html attribute
         *  If anything is passed, the ellipsisCharacters will be
         *  wrapped in <a></a> tags and an event handler for the
         *  passed function will be added to the link
         */
        this.moreClickEmitter = new EventEmitter();
    }
    /**
     * Utility method to quickly find the largest number for
     * which `callback(number)` still returns true.
     * @param {?} max      Highest possible number
     * @param {?} callback Should return true as long as the passed number is valid
     * @return {?} Largest possible number
     */
    static numericBinarySearch(max, callback) {
        /** @type {?} */
        let low = 0;
        /** @type {?} */
        let high = max;
        /** @type {?} */
        let best = -1;
        /** @type {?} */
        let mid;
        while (low <= high) {
            // tslint:disable-next-line:no-bitwise
            mid = ~~((low + high) / 2);
            /** @type {?} */
            const result = callback(mid);
            if (!result) {
                high = mid - 1;
            }
            else {
                best = mid;
                low = mid + 1;
            }
        }
        return best;
    }
    /**
     * Escape html special characters
     * @param {?} unsafe string potentially containing special characters
     * @return {?} escaped string
     */
    static escapeHtml(unsafe) {
        if (unsafe === undefined || unsafe === null) {
            return '';
        }
        return String(unsafe)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    /**
     * Angular's init view life cycle hook.
     * Initializes the element for displaying the ellipsis.
     * @return {?}
     */
    ngAfterViewInit() {
        // let the ellipsis characters default to '...':
        if (this.ellipsisCharacters === '') {
            this.ellipsisCharacters = '...';
        }
        if (this.moreClickEmitter.observers.length > 0) {
            this.ellipsisCharacters = `<a href="#" class="ngx-ellipsis-more">${this.ellipsisCharacters}</a>`;
        }
        // perform regex replace on word boundaries:
        if (!this.ellipsisWordBoundaries) {
            this.ellipsisWordBoundaries = '';
        }
        this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
        // store the original contents of the element:
        this.elem = this.elementRef.nativeElement;
        if (this.ellipsisContent) {
            this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
        }
        else if (!this.originalText) {
            this.originalText = this.elem.innerText;
        }
        // add a wrapper div (required for resize events to work properly):
        this.renderer.setProperty(this.elem, 'innerHTML', '');
        this.innerElem = this.renderer.createElement('div');
        this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
        /** @type {?} */
        const text = this.renderer.createText(this.originalText);
        this.renderer.appendChild(this.innerElem, text);
        this.renderer.appendChild(this.elem, this.innerElem);
        // start listening for resize events:
        this.addResizeListener(true);
    }
    /**
     * Angular's change life cycle hook.
     * Change original text (if the ellipsis-content has been passed)
     * and re-render
     * @return {?}
     */
    ngOnChanges() {
        if (!this.elem
            || typeof this.ellipsisContent === 'undefined'
            || this.originalText === EllipsisDirective.escapeHtml(this.ellipsisContent)) {
            return;
        }
        this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
        this.applyEllipsis();
    }
    /**
     * Angular's destroy life cycle hook.
     * Remove event listeners
     * @return {?}
     */
    ngOnDestroy() {
        this.removeAllListeners();
    }
    /**
     * remove all resize listeners
     * @return {?}
     */
    removeAllListeners() {
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        this.removeResizeListener();
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
     * The type of the listener (window/element) depends on the resizeDetectionStrategy.
     * @param {?=} triggerNow
     * @return {?}
     */
    addResizeListener(triggerNow = false) {
        if (typeof (this.resizeDetectionStrategy) === 'undefined') {
            this.resizeDetectionStrategy = '';
        }
        switch (this.resizeDetectionStrategy) {
            case 'window':
                this.applyOnWindowResize = true;
                if (triggerNow) {
                    this.applyEllipsis();
                }
                break;
            case 'element-resize-detector-object':
                this.addElementResizeListener(false);
                break;
            default:
                if (typeof (console) !== 'undefined') {
                    console.warn(`No such ellipsis-resize-detection strategy: '${this.resizeDetectionStrategy}'. Using 'element-resize-detector' instead`);
                }
            // tslint:disable-next-line:no-switch-case-fall-through
            case 'element-resize-detector':
            case '':
                this.addElementResizeListener();
                break;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.ngZone.run(() => {
            if (this.applyOnWindowResize) {
                this.applyEllipsis();
            }
        });
    }
    /**
     * Set up an event listener to call applyEllipsis() whenever the element
     * has been resized.
     * @param {?=} scrollStrategy
     * @return {?}
     */
    addElementResizeListener(scrollStrategy = true) {
        if (!EllipsisDirective.elementResizeDetector) {
            /** @type {?} */
            const maker = elementResizeDetectorMaker;
            EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
        }
        /** @type {?} */
        let calledAsynchronously = false;
        EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, () => {
            if (!calledAsynchronously) {
                // elementResizeDetector fires the event directly after re-attaching the listener
                // -> discard that first event:
                return;
            }
            this.applyEllipsis();
        });
        calledAsynchronously = true;
    }
    /**
     * Stop listening for any resize event.
     * @return {?}
     */
    removeResizeListener() {
        if (this.resizeDetectionStrategy !== 'window') {
            if (EllipsisDirective.elementResizeDetector && this.elem) {
                EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
            }
        }
        else {
            this.applyOnWindowResize = false;
        }
    }
    /**
     * Get the original text's truncated version. If the text really needed to
     * be truncated, this.ellipsisCharacters will be appended.
     * @param {?} max the maximum length the text may have
     * @return {?} string       the truncated string
     */
    getTruncatedText(max) {
        if (!this.originalText || this.originalText.length <= max) {
            return this.originalText;
        }
        /** @type {?} */
        const truncatedText = this.originalText.substr(0, max);
        if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
            return truncatedText + this.ellipsisCharacters;
        }
        /** @type {?} */
        let i = max - 1;
        while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
            i--;
        }
        return truncatedText.substr(0, i) + this.ellipsisCharacters;
    }
    /**
     * Set the truncated text to be displayed in the inner div
     * @param {?} max the maximum length the text may have
     * @param {?=} addMoreListener
     * @return {?}
     */
    truncateText(max, addMoreListener = false) {
        /** @type {?} */
        const text = this.getTruncatedText(max);
        this.renderer.setProperty(this.innerElem, 'innerHTML', text);
        if (!addMoreListener) {
            return;
        }
        // Remove any existing more click listener:
        if (this.destroyMoreClickListener) {
            this.destroyMoreClickListener();
        }
        // If the text has been truncated, add a more click listener:
        if (text !== this.originalText) {
            this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', (e) => {
                if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                    return;
                }
                e.preventDefault();
                this.moreClickEmitter.emit(e);
            });
        }
    }
    /**
     * Display ellipsis in the inner div if the text would exceed the boundaries
     * @return {?}
     */
    applyEllipsis() {
        // Remove the resize listener as changing the contained text would trigger events:
        this.removeResizeListener();
        // Find the best length by trial and error:
        /** @type {?} */
        const maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, curLength => {
            this.truncateText(curLength);
            return !this.isOverflowing;
        });
        // Apply the best length:
        this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
        // Re-attach the resize listener:
        this.addResizeListener();
    }
    /**
     * Whether the text is exceeding the element's boundaries or not
     * @return {?}
     */
    get isOverflowing() {
        // Enforce hidden overflow (required to compare client width/height with scroll width/height)
        /** @type {?} */
        const currentOverflow = this.elem.style.overflow;
        if (!currentOverflow || currentOverflow === 'visible') {
            this.elem.style.overflow = 'hidden';
        }
        /** @type {?} */
        const isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
        // Reset overflow to the original configuration:
        this.elem.style.overflow = currentOverflow;
        return isOverflowing;
    }
}
/**
 * Instance of https://github.com/wnr/element-resize-detector
 */
EllipsisDirective.elementResizeDetector = null;
EllipsisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ellipsis]'
            },] }
];
/** @nocollapse */
EllipsisDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
EllipsisDirective.propDecorators = {
    ellipsisCharacters: [{ type: Input, args: ['ellipsis',] }],
    ellipsisContent: [{ type: Input, args: ['ellipsis-content',] }],
    ellipsisWordBoundaries: [{ type: Input, args: ['ellipsis-word-boundaries',] }],
    resizeDetectionStrategy: [{ type: Input, args: ['ellipsis-resize-detection',] }],
    moreClickEmitter: [{ type: Output, args: ['ellipsis-click-more',] }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /**
     * Instance of https://github.com/wnr/element-resize-detector
     * @type {?}
     */
    EllipsisDirective.elementResizeDetector;
    /**
     * The original text (not truncated yet)
     * @type {?}
     */
    EllipsisDirective.prototype.originalText;
    /**
     * The referenced element
     * @type {?}
     */
    EllipsisDirective.prototype.elem;
    /**
     * Inner div element (will be auto-created)
     * @type {?}
     */
    EllipsisDirective.prototype.innerElem;
    /**
     * Whether the ellipsis should be applied on window resize
     * @type {?}
     */
    EllipsisDirective.prototype.applyOnWindowResize;
    /**
     * Remove function for the currently registered click listener
     * on the link `this.ellipsisCharacters` are wrapped in.
     * @type {?}
     */
    EllipsisDirective.prototype.destroyMoreClickListener;
    /**
     * The ellipsis html attribute
     * If anything is passed, this will be used as a string to append to
     * the truncated contents.
     * Else '...' will be appended.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisCharacters;
    /**
     * The ellipsis-content html attribute
     * If passed this is used as content, else contents
     * are fetched from innerHTML
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisContent;
    /**
     * The ellipsis-word-boundaries html attribute
     * If anything is passed, each character will be interpreted
     * as a word boundary at which the text may be truncated.
     * Else the text may be truncated at any character.
     * @type {?}
     */
    EllipsisDirective.prototype.ellipsisWordBoundaries;
    /**
     * The ellipsis-resize-detection html attribute
     * Algorithm to use to detect element/window resize - any of the following:
     * 'element-resize-detector': (default) Use https://github.com/wnr/element-resize-detector with its 'scroll' strategy
     * 'element-resize-detector-object': Use https://github.com/wnr/element-resize-detector with its 'object' strategy (deprecated)
     * 'window': Only check if the whole window has been resized/changed orientation by using angular's built-in HostListener
     * @type {?}
     */
    EllipsisDirective.prototype.resizeDetectionStrategy;
    /**
     * The ellipsis-click-more html attribute
     *  If anything is passed, the ellipsisCharacters will be
     *  wrapped in <a></a> tags and an event handler for the
     *  passed function will be added to the link
     * @type {?}
     */
    EllipsisDirective.prototype.moreClickEmitter;
    /** @type {?} */
    EllipsisDirective.prototype.elementRef;
    /** @type {?} */
    EllipsisDirective.prototype.renderer;
    /** @type {?} */
    EllipsisDirective.prototype.ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxsaXBzaXMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWVsbGlwc2lzLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osTUFBTSxFQUNOLFlBQVksRUFJYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEtBQUssMEJBQTBCLE1BQU0seUJBQXlCLENBQUM7Ozs7O0FBU3RFLE1BQU0sT0FBTyxpQkFBaUI7Ozs7Ozs7SUEwSDVCLFlBQTJCLFVBQXNCLEVBQVUsUUFBbUIsRUFBVSxNQUFjO1FBQTNFLGVBQVUsR0FBVixVQUFVLENBQVk7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBUTs7OztRQWxHOUYsd0JBQW1CLEdBQUcsS0FBSyxDQUFDOzs7Ozs7UUFxQlQsb0JBQWUsR0FBVyxJQUFJLENBQUM7Ozs7Ozs7UUF5QjNCLHFCQUFnQixHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO0lBb0RrQixDQUFDOzs7Ozs7OztJQTFDbkcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLEdBQVcsRUFBRSxRQUFnQzs7WUFDMUUsR0FBRyxHQUFHLENBQUM7O1lBQ1AsSUFBSSxHQUFHLEdBQUc7O1lBQ1YsSUFBSSxHQUFHLENBQUMsQ0FBQzs7WUFDVCxHQUFXO1FBRWYsT0FBTyxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ2xCLHNDQUFzQztZQUN0QyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7O2tCQUNyQixNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQztZQUM1QixJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNYLElB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LCtDQUE4Qzs7Ozs7OztJQU85Qyw0Q0FBMEQ7Ozs7Ozs7O0lBUTFELG1EQUFrRTs7Ozs7Ozs7O0lBU2xFLG9EQUEwSTs7Ozs7Ozs7SUFRMUksNkNBQXdGOztJQW9EckUsdUNBQThCOztJQUFFLHFDQUEyQjs7SUFBRSxtQ0FBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIFJlbmRlcmVyMixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxuICBOZ1pvbmUsXG4gIEhvc3RMaXN0ZW5lcixcbiAgT25DaGFuZ2VzLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlciBmcm9tICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic7XG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIHRydW5jYXRlIHRoZSBjb250YWluZWQgdGV4dCwgaWYgaXQgZXhjZWVkcyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXNcbiAqIGFuZCBhcHBlbmQgY2hhcmFjdGVycyAoY29uZmlndXJhYmxlLCBkZWZhdWx0ICcuLi4nKSBpZiBzby5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2VsbGlwc2lzXSdcbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG4gIC8qKlxuICAgKiBJbnN0YW5jZSBvZiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBlbGVtZW50UmVzaXplRGV0ZWN0b3I6IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyLkVyZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCB0ZXh0IChub3QgdHJ1bmNhdGVkIHlldClcbiAgICovXG4gIHByaXZhdGUgb3JpZ2luYWxUZXh0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSByZWZlcmVuY2VkIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBJbm5lciBkaXYgZWxlbWVudCAod2lsbCBiZSBhdXRvLWNyZWF0ZWQpXG4gICAqL1xuICBwcml2YXRlIGlubmVyRWxlbTogYW55O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGxpcHNpcyBzaG91bGQgYmUgYXBwbGllZCBvbiB3aW5kb3cgcmVzaXplXG4gICAqL1xuICBwcml2YXRlIGFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcblxuICAvKipcbiAgICogUmVtb3ZlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgY2xpY2sgbGlzdGVuZXJcbiAgICogb24gdGhlIGxpbmsgYHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzYCBhcmUgd3JhcHBlZCBpbi5cbiAgICovXG4gIHByaXZhdGUgZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCB0aGlzIHdpbGwgYmUgdXNlZCBhcyBhIHN0cmluZyB0byBhcHBlbmQgdG9cbiAgICogdGhlIHRydW5jYXRlZCBjb250ZW50cy5cbiAgICogRWxzZSAnLi4uJyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcycpIGVsbGlwc2lzQ2hhcmFjdGVyczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtY29udGVudCBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBwYXNzZWQgdGhpcyBpcyB1c2VkIGFzIGNvbnRlbnQsIGVsc2UgY29udGVudHNcbiAgICogYXJlIGZldGNoZWQgZnJvbSBpbm5lckhUTUxcbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtY29udGVudCcpIGVsbGlwc2lzQ29udGVudDogc3RyaW5nID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLXdvcmQtYm91bmRhcmllcyBodG1sIGF0dHJpYnV0ZVxuICAgKiBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIGVhY2ggY2hhcmFjdGVyIHdpbGwgYmUgaW50ZXJwcmV0ZWRcbiAgICogYXMgYSB3b3JkIGJvdW5kYXJ5IGF0IHdoaWNoIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQuXG4gICAqIEVsc2UgdGhlIHRleHQgbWF5IGJlIHRydW5jYXRlZCBhdCBhbnkgY2hhcmFjdGVyLlxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMnKSBlbGxpcHNpc1dvcmRCb3VuZGFyaWVzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIGh0bWwgYXR0cmlidXRlXG4gICAqIEFsZ29yaXRobSB0byB1c2UgdG8gZGV0ZWN0IGVsZW1lbnQvd2luZG93IHJlc2l6ZSAtIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InOiAoZGVmYXVsdCkgVXNlIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Igd2l0aCBpdHMgJ3Njcm9sbCcgc3RyYXRlZ3lcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6IFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdvYmplY3QnIHN0cmF0ZWd5IChkZXByZWNhdGVkKVxuICAgKiAnd2luZG93JzogT25seSBjaGVjayBpZiB0aGUgd2hvbGUgd2luZG93IGhhcyBiZWVuIHJlc2l6ZWQvY2hhbmdlZCBvcmllbnRhdGlvbiBieSB1c2luZyBhbmd1bGFyJ3MgYnVpbHQtaW4gSG9zdExpc3RlbmVyXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24nKSByZXNpemVEZXRlY3Rpb25TdHJhdGVneTogJycgfCAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCcgfCAnd2luZG93JztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNsaWNrLW1vcmUgaHRtbCBhdHRyaWJ1dGVcbiAgICogIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlXG4gICAqICB3cmFwcGVkIGluIDxhPjwvYT4gdGFncyBhbmQgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlXG4gICAqICBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgbGlua1xuICAgKi9cbiAgQE91dHB1dCgnZWxsaXBzaXMtY2xpY2stbW9yZScpIG1vcmVDbGlja0VtaXR0ZXI6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIHRvIHF1aWNrbHkgZmluZCB0aGUgbGFyZ2VzdCBudW1iZXIgZm9yXG4gICAqIHdoaWNoIGBjYWxsYmFjayhudW1iZXIpYCBzdGlsbCByZXR1cm5zIHRydWUuXG4gICAqIEBwYXJhbSAgbWF4ICAgICAgSGlnaGVzdCBwb3NzaWJsZSBudW1iZXJcbiAgICogQHBhcmFtICBjYWxsYmFjayBTaG91bGQgcmV0dXJuIHRydWUgYXMgbG9uZyBhcyB0aGUgcGFzc2VkIG51bWJlciBpcyB2YWxpZFxuICAgKiBAcmV0dXJuICAgICAgICAgIExhcmdlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBudW1lcmljQmluYXJ5U2VhcmNoKG1heDogbnVtYmVyLCBjYWxsYmFjazogKG46IG51bWJlcikgPT4gYm9vbGVhbik6IG51bWJlciB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBtYXg7XG4gICAgbGV0IGJlc3QgPSAtMTtcbiAgICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICBtaWQgPSB+figobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKG1pZCk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlc3QgPSBtaWQ7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3Q7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlIGh0bWwgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAqIEBwYXJhbSB1bnNhZmUgc3RyaW5nIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAqIEByZXR1cm4gICAgICAgZXNjYXBlZCBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGVzY2FwZUh0bWwodW5zYWZlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICh1bnNhZmUgPT09IHVuZGVmaW5lZCB8fCB1bnNhZmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nKHVuc2FmZSlcbiAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7Jyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRpcmVjdGl2ZSdzIGNvbnN0cnVjdG9yXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgaW5pdCB2aWV3IGxpZmUgY3ljbGUgaG9vay5cbiAgICogSW5pdGlhbGl6ZXMgdGhlIGVsZW1lbnQgZm9yIGRpc3BsYXlpbmcgdGhlIGVsbGlwc2lzLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIGxldCB0aGUgZWxsaXBzaXMgY2hhcmFjdGVycyBkZWZhdWx0IHRvICcuLi4nOlxuICAgIGlmICh0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9PT0gJycpIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gJy4uLic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPSBgPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm5neC1lbGxpcHNpcy1tb3JlXCI+JHt0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc308L2E+YDtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHJlZ2V4IHJlcGxhY2Ugb24gd29yZCBib3VuZGFyaWVzOlxuICAgIGlmICghdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMgPSAnJztcbiAgICB9XG4gICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJ1snICsgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpICsgJ10nO1xuXG4gICAgLy8gc3RvcmUgdGhlIG9yaWdpbmFsIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50OlxuICAgIHRoaXMuZWxlbSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGlmICh0aGlzLmVsbGlwc2lzQ29udGVudCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSBFbGxpcHNpc0RpcmVjdGl2ZS5lc2NhcGVIdG1sKHRoaXMuZWxsaXBzaXNDb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmVsZW0uaW5uZXJUZXh0O1xuICAgIH1cblxuICAgIC8vIGFkZCBhIHdyYXBwZXIgZGl2IChyZXF1aXJlZCBmb3IgcmVzaXplIGV2ZW50cyB0byB3b3JrIHByb3Blcmx5KTpcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWxlbSwgJ2lubmVySFRNTCcsICcnKTtcbiAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmlubmVyRWxlbSwgJ25neC1lbGxpcHNpcy1pbm5lcicpO1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZVRleHQodGhpcy5vcmlnaW5hbFRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0sIHRleHQpO1xuICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtLCB0aGlzLmlubmVyRWxlbSk7XG5cbiAgICAvLyBzdGFydCBsaXN0ZW5pbmcgZm9yIHJlc2l6ZSBldmVudHM6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcih0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmd1bGFyJ3MgY2hhbmdlIGxpZmUgY3ljbGUgaG9vay5cbiAgICogQ2hhbmdlIG9yaWdpbmFsIHRleHQgKGlmIHRoZSBlbGxpcHNpcy1jb250ZW50IGhhcyBiZWVuIHBhc3NlZClcbiAgICogYW5kIHJlLXJlbmRlclxuICAgKi9cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1cbiAgICAgIHx8IHR5cGVvZiB0aGlzLmVsbGlwc2lzQ29udGVudCA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgIHx8IHRoaXMub3JpZ2luYWxUZXh0ID09PSBFbGxpcHNpc0RpcmVjdGl2ZS5lc2NhcGVIdG1sKHRoaXMuZWxsaXBzaXNDb250ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gRWxsaXBzaXNEaXJlY3RpdmUuZXNjYXBlSHRtbCh0aGlzLmVsbGlwc2lzQ29udGVudCk7XG4gICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGRlc3Ryb3kgbGlmZSBjeWNsZSBob29rLlxuICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlbW92ZSBhbGwgcmVzaXplIGxpc3RlbmVyc1xuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlUmVzaXplTGlzdGVuZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldCB1cCBhbiBldmVudCBsaXN0ZW5lciB0byBjYWxsIGFwcGx5RWxsaXBzaXMoKSB3aGVuZXZlciBhIHJlc2l6ZSBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgbGlzdGVuZXIgKHdpbmRvdy9lbGVtZW50KSBkZXBlbmRzIG9uIHRoZSByZXNpemVEZXRlY3Rpb25TdHJhdGVneS5cbiAgICogQHBhcmFtIHRyaWdnZXJOb3c9ZmFsc2UgaWYgdHJ1ZSwgdGhlIGVsbGlwc2lzIGlzIGFwcGxpZWQgaW1tZWRpYXRlbHlcbiAgICovXG4gIHByaXZhdGUgYWRkUmVzaXplTGlzdGVuZXIodHJpZ2dlck5vdyA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ID0gJyc7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICB0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUgPSB0cnVlO1xuICAgICAgICBpZiAodHJpZ2dlck5vdykge1xuICAgICAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3Itb2JqZWN0JzpcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnNvbGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBObyBzdWNoIGVsbGlwc2lzLXJlc2l6ZS1kZXRlY3Rpb24gc3RyYXRlZ3k6ICcke3RoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3l9Jy4gVXNpbmcgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJyBpbnN0ZWFkYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zd2l0Y2gtY2FzZS1mYWxsLXRocm91Z2hcbiAgICAgIGNhc2UgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzpcbiAgICAgIGNhc2UgJyc6XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnLCBbJyRldmVudCddKSBvblJlc2l6ZShldmVudDogRXZlbnQpIHtcbiAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgdGhlIGVsZW1lbnRcbiAgICogaGFzIGJlZW4gcmVzaXplZC5cbiAgICogQHBhcmFtIHNjcm9sbFN0cmF0ZWd5PXRydWUgVXNlIHRoZSBkZWZhdWx0IGVsZW1lbnRSZXNpemVEZXRlY3RvcidzIC0gc3RyYXRlZ3kgLSBzLiBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yXG4gICAqL1xuICBwcml2YXRlIGFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcihzY3JvbGxTdHJhdGVneSA9IHRydWUpIHtcbiAgICBpZiAoIUVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvcikge1xuICAgICAgY29uc3QgbWFrZXI6IGFueSA9IGVsZW1lbnRSZXNpemVEZXRlY3Rvck1ha2VyO1xuICAgICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yID0gbWFrZXIoeyBzdHJhdGVneTogc2Nyb2xsU3RyYXRlZ3kgPyAnc2Nyb2xsJyA6ICdvYmplY3QnIH0pO1xuICAgIH1cblxuXG4gICAgbGV0IGNhbGxlZEFzeW5jaHJvbm91c2x5ID0gZmFsc2U7XG4gICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yLmxpc3RlblRvKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAoKSA9PiB7XG4gICAgICBpZiAoIWNhbGxlZEFzeW5jaHJvbm91c2x5KSB7XG4gICAgICAgIC8vIGVsZW1lbnRSZXNpemVEZXRlY3RvciBmaXJlcyB0aGUgZXZlbnQgZGlyZWN0bHkgYWZ0ZXIgcmUtYXR0YWNoaW5nIHRoZSBsaXN0ZW5lclxuICAgICAgICAvLyAtPiBkaXNjYXJkIHRoYXQgZmlyc3QgZXZlbnQ6XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICAgIH0pO1xuICAgIGNhbGxlZEFzeW5jaHJvbm91c2x5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYW55IHJlc2l6ZSBldmVudC5cbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlUmVzaXplTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kgIT09ICd3aW5kb3cnKSB7XG4gICAgICBpZiAoRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yICYmIHRoaXMuZWxlbSkge1xuICAgICAgICBFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IucmVtb3ZlQWxsTGlzdGVuZXJzKHRoaXMuZWxlbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlPbldpbmRvd1Jlc2l6ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9yaWdpbmFsIHRleHQncyB0cnVuY2F0ZWQgdmVyc2lvbi4gSWYgdGhlIHRleHQgcmVhbGx5IG5lZWRlZCB0b1xuICAgKiBiZSB0cnVuY2F0ZWQsIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzIHdpbGwgYmUgYXBwZW5kZWQuXG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEByZXR1cm4gc3RyaW5nICAgICAgIHRoZSB0cnVuY2F0ZWQgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIGdldFRydW5jYXRlZFRleHQobWF4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5vcmlnaW5hbFRleHQgfHwgdGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoIDw9IG1heCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxUZXh0O1xuICAgIH1cblxuICAgIGNvbnN0IHRydW5jYXRlZFRleHQgPSB0aGlzLm9yaWdpbmFsVGV4dC5zdWJzdHIoMCwgbWF4KTtcbiAgICBpZiAodGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID09PSAnW10nIHx8IHRoaXMub3JpZ2luYWxUZXh0LmNoYXJBdChtYXgpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIHJldHVybiB0cnVuY2F0ZWRUZXh0ICsgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgbGV0IGkgPSBtYXggLSAxO1xuICAgIHdoaWxlIChpID4gMCAmJiAhdHJ1bmNhdGVkVGV4dC5jaGFyQXQoaSkubWF0Y2godGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzKSkge1xuICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dC5zdWJzdHIoMCwgaSkgKyB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRydW5jYXRlZCB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgaW5uZXIgZGl2XG4gICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIHRoZSB0ZXh0IG1heSBoYXZlXG4gICAqIEBwYXJhbSBhZGRNb3JlTGlzdGVuZXI9ZmFsc2UgbGlzdGVuIGZvciBjbGljayBvbiB0aGUgZWxsaXBzaXNDaGFyYWN0ZXJzIGlmIHRoZSB0ZXh0IGhhcyBiZWVuIHRydW5jYXRlZFxuICAgKi9cbiAgcHJpdmF0ZSB0cnVuY2F0ZVRleHQobWF4OiBudW1iZXIsIGFkZE1vcmVMaXN0ZW5lciA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMuZ2V0VHJ1bmNhdGVkVGV4dChtYXgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5pbm5lckVsZW0sICdpbm5lckhUTUwnLCB0ZXh0KTtcblxuICAgIGlmICghYWRkTW9yZUxpc3RlbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBtb3JlIGNsaWNrIGxpc3RlbmVyOlxuICAgIGlmICh0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGV4dCBoYXMgYmVlbiB0cnVuY2F0ZWQsIGFkZCBhIG1vcmUgY2xpY2sgbGlzdGVuZXI6XG4gICAgaWYgKHRleHQgIT09IHRoaXMub3JpZ2luYWxUZXh0KSB7XG4gICAgICB0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuaW5uZXJFbGVtLCAnY2xpY2snLCAoZTogYW55KSA9PiB7XG4gICAgICAgIGlmICghZS50YXJnZXQgfHwgZS50YXJnZXQuY2xhc3NOYW1lICE9PSAnbmd4LWVsbGlwc2lzLW1vcmUnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5tb3JlQ2xpY2tFbWl0dGVyLmVtaXQoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheSBlbGxpcHNpcyBpbiB0aGUgaW5uZXIgZGl2IGlmIHRoZSB0ZXh0IHdvdWxkIGV4Y2VlZCB0aGUgYm91bmRhcmllc1xuICAgKi9cbiAgcHJpdmF0ZSBhcHBseUVsbGlwc2lzKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgcmVzaXplIGxpc3RlbmVyIGFzIGNoYW5naW5nIHRoZSBjb250YWluZWQgdGV4dCB3b3VsZCB0cmlnZ2VyIGV2ZW50czpcbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKCk7XG5cbiAgICAvLyBGaW5kIHRoZSBiZXN0IGxlbmd0aCBieSB0cmlhbCBhbmQgZXJyb3I6XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gRWxsaXBzaXNEaXJlY3RpdmUubnVtZXJpY0JpbmFyeVNlYXJjaCh0aGlzLm9yaWdpbmFsVGV4dC5sZW5ndGgsIGN1ckxlbmd0aCA9PiB7XG4gICAgICB0aGlzLnRydW5jYXRlVGV4dChjdXJMZW5ndGgpO1xuICAgICAgcmV0dXJuICF0aGlzLmlzT3ZlcmZsb3dpbmc7XG4gICAgfSk7XG5cbiAgICAvLyBBcHBseSB0aGUgYmVzdCBsZW5ndGg6XG4gICAgdGhpcy50cnVuY2F0ZVRleHQobWF4TGVuZ3RoLCAodGhpcy5tb3JlQ2xpY2tFbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwKSk7XG5cbiAgICAvLyBSZS1hdHRhY2ggdGhlIHJlc2l6ZSBsaXN0ZW5lcjpcbiAgICB0aGlzLmFkZFJlc2l6ZUxpc3RlbmVyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0ZXh0IGlzIGV4Y2VlZGluZyB0aGUgZWxlbWVudCdzIGJvdW5kYXJpZXMgb3Igbm90XG4gICAqL1xuICBwcml2YXRlIGdldCBpc092ZXJmbG93aW5nKCk6IGJvb2xlYW4ge1xuICAgIC8vIEVuZm9yY2UgaGlkZGVuIG92ZXJmbG93IChyZXF1aXJlZCB0byBjb21wYXJlIGNsaWVudCB3aWR0aC9oZWlnaHQgd2l0aCBzY3JvbGwgd2lkdGgvaGVpZ2h0KVxuICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvdyA9IHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdztcbiAgICBpZiAoIWN1cnJlbnRPdmVyZmxvdyB8fCBjdXJyZW50T3ZlcmZsb3cgPT09ICd2aXNpYmxlJykge1xuICAgICAgdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgY29uc3QgaXNPdmVyZmxvd2luZyA9IHRoaXMuZWxlbS5jbGllbnRXaWR0aCA8IHRoaXMuZWxlbS5zY3JvbGxXaWR0aCAtIDEgfHwgdGhpcy5lbGVtLmNsaWVudEhlaWdodCA8IHRoaXMuZWxlbS5zY3JvbGxIZWlnaHQgLSAxO1xuXG4gICAgLy8gUmVzZXQgb3ZlcmZsb3cgdG8gdGhlIG9yaWdpbmFsIGNvbmZpZ3VyYXRpb246XG4gICAgdGhpcy5lbGVtLnN0eWxlLm92ZXJmbG93ID0gY3VycmVudE92ZXJmbG93O1xuXG4gICAgcmV0dXJuIGlzT3ZlcmZsb3dpbmc7XG4gIH1cbn1cbiJdfQ==