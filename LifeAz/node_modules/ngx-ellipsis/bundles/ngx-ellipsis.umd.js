(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('element-resize-detector')) :
    typeof define === 'function' && define.amd ? define('ngx-ellipsis', ['exports', '@angular/core', 'element-resize-detector'], factory) :
    (factory((global['ngx-ellipsis'] = {}),global.ng.core,global.elementResizeDetectorMaker));
}(this, (function (exports,core,elementResizeDetectorMaker) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Directive to truncate the contained text, if it exceeds the element's boundaries
     * and append characters (configurable, default '...') if so.
     */
    var EllipsisDirective = /** @class */ (function () {
        /**
         * The directive's constructor
         */
        function EllipsisDirective(elementRef, renderer, ngZone) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.ngZone = ngZone;
            /**
             * Whether the ellipsis should be applied on window resize
             */
            this.applyOnWindowResize = false;
            /**
             * The ellipsis-content html attribute
             * If passed this is used as content, else contents
             * are fetched from innerHTML
             */
            this.ellipsisContent = null;
            /**
             * The ellipsis-click-more html attribute
             *  If anything is passed, the ellipsisCharacters will be
             *  wrapped in <a></a> tags and an event handler for the
             *  passed function will be added to the link
             */
            this.moreClickEmitter = new core.EventEmitter();
        }
        /**
         * Utility method to quickly find the largest number for
         * which `callback(number)` still returns true.
         * @param  max      Highest possible number
         * @param  callback Should return true as long as the passed number is valid
         * @return          Largest possible number
         */
        /**
         * Utility method to quickly find the largest number for
         * which `callback(number)` still returns true.
         * @param {?} max      Highest possible number
         * @param {?} callback Should return true as long as the passed number is valid
         * @return {?} Largest possible number
         */
        EllipsisDirective.numericBinarySearch = /**
         * Utility method to quickly find the largest number for
         * which `callback(number)` still returns true.
         * @param {?} max      Highest possible number
         * @param {?} callback Should return true as long as the passed number is valid
         * @return {?} Largest possible number
         */
            function (max, callback) {
                /** @type {?} */
                var low = 0;
                /** @type {?} */
                var high = max;
                /** @type {?} */
                var best = -1;
                /** @type {?} */
                var mid;
                while (low <= high) {
                    // tslint:disable-next-line:no-bitwise
                    mid = ~~((low + high) / 2);
                    /** @type {?} */
                    var result = callback(mid);
                    if (!result) {
                        high = mid - 1;
                    }
                    else {
                        best = mid;
                        low = mid + 1;
                    }
                }
                return best;
            };
        /**
         * Escape html special characters
         * @param unsafe string potentially containing special characters
         * @return       escaped string
         */
        /**
         * Escape html special characters
         * @param {?} unsafe string potentially containing special characters
         * @return {?} escaped string
         */
        EllipsisDirective.escapeHtml = /**
         * Escape html special characters
         * @param {?} unsafe string potentially containing special characters
         * @return {?} escaped string
         */
            function (unsafe) {
                if (unsafe === undefined || unsafe === null) {
                    return '';
                }
                return String(unsafe)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            };
        /**
         * Angular's init view life cycle hook.
         * Initializes the element for displaying the ellipsis.
         */
        /**
         * Angular's init view life cycle hook.
         * Initializes the element for displaying the ellipsis.
         * @return {?}
         */
        EllipsisDirective.prototype.ngAfterViewInit = /**
         * Angular's init view life cycle hook.
         * Initializes the element for displaying the ellipsis.
         * @return {?}
         */
            function () {
                // let the ellipsis characters default to '...':
                if (this.ellipsisCharacters === '') {
                    this.ellipsisCharacters = '...';
                }
                if (this.moreClickEmitter.observers.length > 0) {
                    this.ellipsisCharacters = "<a href=\"#\" class=\"ngx-ellipsis-more\">" + this.ellipsisCharacters + "</a>";
                }
                // perform regex replace on word boundaries:
                if (!this.ellipsisWordBoundaries) {
                    this.ellipsisWordBoundaries = '';
                }
                this.ellipsisWordBoundaries = '[' + this.ellipsisWordBoundaries.replace(/\\n/, '\n').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + ']';
                // store the original contents of the element:
                this.elem = this.elementRef.nativeElement;
                if (this.ellipsisContent) {
                    this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
                }
                else if (!this.originalText) {
                    this.originalText = this.elem.innerText;
                }
                // add a wrapper div (required for resize events to work properly):
                this.renderer.setProperty(this.elem, 'innerHTML', '');
                this.innerElem = this.renderer.createElement('div');
                this.renderer.addClass(this.innerElem, 'ngx-ellipsis-inner');
                /** @type {?} */
                var text = this.renderer.createText(this.originalText);
                this.renderer.appendChild(this.innerElem, text);
                this.renderer.appendChild(this.elem, this.innerElem);
                // start listening for resize events:
                this.addResizeListener(true);
            };
        /**
         * Angular's change life cycle hook.
         * Change original text (if the ellipsis-content has been passed)
         * and re-render
         */
        /**
         * Angular's change life cycle hook.
         * Change original text (if the ellipsis-content has been passed)
         * and re-render
         * @return {?}
         */
        EllipsisDirective.prototype.ngOnChanges = /**
         * Angular's change life cycle hook.
         * Change original text (if the ellipsis-content has been passed)
         * and re-render
         * @return {?}
         */
            function () {
                if (!this.elem
                    || typeof this.ellipsisContent === 'undefined'
                    || this.originalText === EllipsisDirective.escapeHtml(this.ellipsisContent)) {
                    return;
                }
                this.originalText = EllipsisDirective.escapeHtml(this.ellipsisContent);
                this.applyEllipsis();
            };
        /**
         * Angular's destroy life cycle hook.
         * Remove event listeners
         */
        /**
         * Angular's destroy life cycle hook.
         * Remove event listeners
         * @return {?}
         */
        EllipsisDirective.prototype.ngOnDestroy = /**
         * Angular's destroy life cycle hook.
         * Remove event listeners
         * @return {?}
         */
            function () {
                this.removeAllListeners();
            };
        /**
         * remove all resize listeners
         */
        /**
         * remove all resize listeners
         * @return {?}
         */
        EllipsisDirective.prototype.removeAllListeners = /**
         * remove all resize listeners
         * @return {?}
         */
            function () {
                if (this.destroyMoreClickListener) {
                    this.destroyMoreClickListener();
                }
                this.removeResizeListener();
            };
        /**
         * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
         * The type of the listener (window/element) depends on the resizeDetectionStrategy.
         * @param triggerNow=false if true, the ellipsis is applied immediately
         */
        /**
         * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
         * The type of the listener (window/element) depends on the resizeDetectionStrategy.
         * @param {?=} triggerNow
         * @return {?}
         */
        EllipsisDirective.prototype.addResizeListener = /**
         * Set up an event listener to call applyEllipsis() whenever a resize has been registered.
         * The type of the listener (window/element) depends on the resizeDetectionStrategy.
         * @param {?=} triggerNow
         * @return {?}
         */
            function (triggerNow) {
                if (triggerNow === void 0) {
                    triggerNow = false;
                }
                if (typeof (this.resizeDetectionStrategy) === 'undefined') {
                    this.resizeDetectionStrategy = '';
                }
                switch (this.resizeDetectionStrategy) {
                    case 'window':
                        this.applyOnWindowResize = true;
                        if (triggerNow) {
                            this.applyEllipsis();
                        }
                        break;
                    case 'element-resize-detector-object':
                        this.addElementResizeListener(false);
                        break;
                    default:
                        if (typeof (console) !== 'undefined') {
                            console.warn("No such ellipsis-resize-detection strategy: '" + this.resizeDetectionStrategy + "'. Using 'element-resize-detector' instead");
                        }
                    // tslint:disable-next-line:no-switch-case-fall-through
                    case 'element-resize-detector':
                    case '':
                        this.addElementResizeListener();
                        break;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        EllipsisDirective.prototype.onResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.ngZone.run(function () {
                    if (_this.applyOnWindowResize) {
                        _this.applyEllipsis();
                    }
                });
            };
        /**
         * Set up an event listener to call applyEllipsis() whenever the element
         * has been resized.
         * @param scrollStrategy=true Use the default elementResizeDetector's - strategy - s. https://github.com/wnr/element-resize-detector
         */
        /**
         * Set up an event listener to call applyEllipsis() whenever the element
         * has been resized.
         * @param {?=} scrollStrategy
         * @return {?}
         */
        EllipsisDirective.prototype.addElementResizeListener = /**
         * Set up an event listener to call applyEllipsis() whenever the element
         * has been resized.
         * @param {?=} scrollStrategy
         * @return {?}
         */
            function (scrollStrategy) {
                var _this = this;
                if (scrollStrategy === void 0) {
                    scrollStrategy = true;
                }
                if (!EllipsisDirective.elementResizeDetector) {
                    /** @type {?} */
                    var maker = elementResizeDetectorMaker;
                    EllipsisDirective.elementResizeDetector = maker({ strategy: scrollStrategy ? 'scroll' : 'object' });
                }
                /** @type {?} */
                var calledAsynchronously = false;
                EllipsisDirective.elementResizeDetector.listenTo(this.elementRef.nativeElement, function () {
                    if (!calledAsynchronously) {
                        // elementResizeDetector fires the event directly after re-attaching the listener
                        // -> discard that first event:
                        return;
                    }
                    _this.applyEllipsis();
                });
                calledAsynchronously = true;
            };
        /**
         * Stop listening for any resize event.
         */
        /**
         * Stop listening for any resize event.
         * @return {?}
         */
        EllipsisDirective.prototype.removeResizeListener = /**
         * Stop listening for any resize event.
         * @return {?}
         */
            function () {
                if (this.resizeDetectionStrategy !== 'window') {
                    if (EllipsisDirective.elementResizeDetector && this.elem) {
                        EllipsisDirective.elementResizeDetector.removeAllListeners(this.elem);
                    }
                }
                else {
                    this.applyOnWindowResize = false;
                }
            };
        /**
         * Get the original text's truncated version. If the text really needed to
         * be truncated, this.ellipsisCharacters will be appended.
         * @param max the maximum length the text may have
         * @return string       the truncated string
         */
        /**
         * Get the original text's truncated version. If the text really needed to
         * be truncated, this.ellipsisCharacters will be appended.
         * @param {?} max the maximum length the text may have
         * @return {?} string       the truncated string
         */
        EllipsisDirective.prototype.getTruncatedText = /**
         * Get the original text's truncated version. If the text really needed to
         * be truncated, this.ellipsisCharacters will be appended.
         * @param {?} max the maximum length the text may have
         * @return {?} string       the truncated string
         */
            function (max) {
                if (!this.originalText || this.originalText.length <= max) {
                    return this.originalText;
                }
                /** @type {?} */
                var truncatedText = this.originalText.substr(0, max);
                if (this.ellipsisWordBoundaries === '[]' || this.originalText.charAt(max).match(this.ellipsisWordBoundaries)) {
                    return truncatedText + this.ellipsisCharacters;
                }
                /** @type {?} */
                var i = max - 1;
                while (i > 0 && !truncatedText.charAt(i).match(this.ellipsisWordBoundaries)) {
                    i--;
                }
                return truncatedText.substr(0, i) + this.ellipsisCharacters;
            };
        /**
         * Set the truncated text to be displayed in the inner div
         * @param max the maximum length the text may have
         * @param addMoreListener=false listen for click on the ellipsisCharacters if the text has been truncated
         */
        /**
         * Set the truncated text to be displayed in the inner div
         * @param {?} max the maximum length the text may have
         * @param {?=} addMoreListener
         * @return {?}
         */
        EllipsisDirective.prototype.truncateText = /**
         * Set the truncated text to be displayed in the inner div
         * @param {?} max the maximum length the text may have
         * @param {?=} addMoreListener
         * @return {?}
         */
            function (max, addMoreListener) {
                var _this = this;
                if (addMoreListener === void 0) {
                    addMoreListener = false;
                }
                /** @type {?} */
                var text = this.getTruncatedText(max);
                this.renderer.setProperty(this.innerElem, 'innerHTML', text);
                if (!addMoreListener) {
                    return;
                }
                // Remove any existing more click listener:
                if (this.destroyMoreClickListener) {
                    this.destroyMoreClickListener();
                }
                // If the text has been truncated, add a more click listener:
                if (text !== this.originalText) {
                    this.destroyMoreClickListener = this.renderer.listen(this.innerElem, 'click', function (e) {
                        if (!e.target || e.target.className !== 'ngx-ellipsis-more') {
                            return;
                        }
                        e.preventDefault();
                        _this.moreClickEmitter.emit(e);
                    });
                }
            };
        /**
         * Display ellipsis in the inner div if the text would exceed the boundaries
         */
        /**
         * Display ellipsis in the inner div if the text would exceed the boundaries
         * @return {?}
         */
        EllipsisDirective.prototype.applyEllipsis = /**
         * Display ellipsis in the inner div if the text would exceed the boundaries
         * @return {?}
         */
            function () {
                var _this = this;
                // Remove the resize listener as changing the contained text would trigger events:
                this.removeResizeListener();
                // Find the best length by trial and error:
                /** @type {?} */
                var maxLength = EllipsisDirective.numericBinarySearch(this.originalText.length, function (curLength) {
                    _this.truncateText(curLength);
                    return !_this.isOverflowing;
                });
                // Apply the best length:
                this.truncateText(maxLength, (this.moreClickEmitter.observers.length > 0));
                // Re-attach the resize listener:
                this.addResizeListener();
            };
        Object.defineProperty(EllipsisDirective.prototype, "isOverflowing", {
            /**
             * Whether the text is exceeding the element's boundaries or not
             */
            get: /**
             * Whether the text is exceeding the element's boundaries or not
             * @return {?}
             */ function () {
                // Enforce hidden overflow (required to compare client width/height with scroll width/height)
                /** @type {?} */
                var currentOverflow = this.elem.style.overflow;
                if (!currentOverflow || currentOverflow === 'visible') {
                    this.elem.style.overflow = 'hidden';
                }
                /** @type {?} */
                var isOverflowing = this.elem.clientWidth < this.elem.scrollWidth - 1 || this.elem.clientHeight < this.elem.scrollHeight - 1;
                // Reset overflow to the original configuration:
                this.elem.style.overflow = currentOverflow;
                return isOverflowing;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Instance of https://github.com/wnr/element-resize-detector
         */
        EllipsisDirective.elementResizeDetector = null;
        EllipsisDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ellipsis]'
                    },] }
        ];
        /** @nocollapse */
        EllipsisDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: core.NgZone }
            ];
        };
        EllipsisDirective.propDecorators = {
            ellipsisCharacters: [{ type: core.Input, args: ['ellipsis',] }],
            ellipsisContent: [{ type: core.Input, args: ['ellipsis-content',] }],
            ellipsisWordBoundaries: [{ type: core.Input, args: ['ellipsis-word-boundaries',] }],
            resizeDetectionStrategy: [{ type: core.Input, args: ['ellipsis-resize-detection',] }],
            moreClickEmitter: [{ type: core.Output, args: ['ellipsis-click-more',] }],
            onResize: [{ type: core.HostListener, args: ['window:resize', ['$event'],] }]
        };
        return EllipsisDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var EllipsisModule = /** @class */ (function () {
        function EllipsisModule() {
        }
        EllipsisModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [EllipsisDirective],
                        exports: [EllipsisDirective]
                    },] }
        ];
        return EllipsisModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.EllipsisDirective = EllipsisDirective;
    exports.EllipsisModule = EllipsisModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWVsbGlwc2lzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vbmd4LWVsbGlwc2lzL2xpYi9kaXJlY3RpdmVzL2VsbGlwc2lzLmRpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWVsbGlwc2lzL2xpYi9lbGxpcHNpcy5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBSZW5kZXJlcjIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgTmdab25lLFxuICBIb3N0TGlzdGVuZXIsXG4gIE9uQ2hhbmdlcyxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgZWxlbWVudFJlc2l6ZURldGVjdG9yTWFrZXIgZnJvbSAnZWxlbWVudC1yZXNpemUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIERpcmVjdGl2ZSB0byB0cnVuY2F0ZSB0aGUgY29udGFpbmVkIHRleHQsIGlmIGl0IGV4Y2VlZHMgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzXG4gKiBhbmQgYXBwZW5kIGNoYXJhY3RlcnMgKGNvbmZpZ3VyYWJsZSwgZGVmYXVsdCAnLi4uJykgaWYgc28uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tlbGxpcHNpc10nXG59KVxuZXhwb3J0IGNsYXNzIEVsbGlwc2lzRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQge1xuICAvKipcbiAgICogSW5zdGFuY2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZWxlbWVudFJlc2l6ZURldGVjdG9yOiBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlci5FcmQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgdGV4dCAobm90IHRydW5jYXRlZCB5ZXQpXG4gICAqL1xuICBwcml2YXRlIG9yaWdpbmFsVGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVmZXJlbmNlZCBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIGVsZW06IGFueTtcblxuICAvKipcbiAgICogSW5uZXIgZGl2IGVsZW1lbnQgKHdpbGwgYmUgYXV0by1jcmVhdGVkKVxuICAgKi9cbiAgcHJpdmF0ZSBpbm5lckVsZW06IGFueTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZWxsaXBzaXMgc2hvdWxkIGJlIGFwcGxpZWQgb24gd2luZG93IHJlc2l6ZVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBseU9uV2luZG93UmVzaXplID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIGNsaWNrIGxpc3RlbmVyXG4gICAqIG9uIHRoZSBsaW5rIGB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVyc2AgYXJlIHdyYXBwZWQgaW4uXG4gICAqL1xuICBwcml2YXRlIGRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzIGh0bWwgYXR0cmlidXRlXG4gICAqIElmIGFueXRoaW5nIGlzIHBhc3NlZCwgdGhpcyB3aWxsIGJlIHVzZWQgYXMgYSBzdHJpbmcgdG8gYXBwZW5kIHRvXG4gICAqIHRoZSB0cnVuY2F0ZWQgY29udGVudHMuXG4gICAqIEVsc2UgJy4uLicgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMnKSBlbGxpcHNpc0NoYXJhY3RlcnM6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGVsbGlwc2lzLWNvbnRlbnQgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgcGFzc2VkIHRoaXMgaXMgdXNlZCBhcyBjb250ZW50LCBlbHNlIGNvbnRlbnRzXG4gICAqIGFyZSBmZXRjaGVkIGZyb20gaW5uZXJIVE1MXG4gICAqL1xuICBASW5wdXQoJ2VsbGlwc2lzLWNvbnRlbnQnKSBlbGxpcHNpc0NvbnRlbnQ6IHN0cmluZyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy13b3JkLWJvdW5kYXJpZXMgaHRtbCBhdHRyaWJ1dGVcbiAgICogSWYgYW55dGhpbmcgaXMgcGFzc2VkLCBlYWNoIGNoYXJhY3RlciB3aWxsIGJlIGludGVycHJldGVkXG4gICAqIGFzIGEgd29yZCBib3VuZGFyeSBhdCB3aGljaCB0aGUgdGV4dCBtYXkgYmUgdHJ1bmNhdGVkLlxuICAgKiBFbHNlIHRoZSB0ZXh0IG1heSBiZSB0cnVuY2F0ZWQgYXQgYW55IGNoYXJhY3Rlci5cbiAgICovXG4gIEBJbnB1dCgnZWxsaXBzaXMtd29yZC1ib3VuZGFyaWVzJykgZWxsaXBzaXNXb3JkQm91bmRhcmllczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZWxsaXBzaXMtcmVzaXplLWRldGVjdGlvbiBodG1sIGF0dHJpYnV0ZVxuICAgKiBBbGdvcml0aG0gdG8gdXNlIHRvIGRldGVjdCBlbGVtZW50L3dpbmRvdyByZXNpemUgLSBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJzogKGRlZmF1bHQpIFVzZSBodHRwczovL2dpdGh1Yi5jb20vd25yL2VsZW1lbnQtcmVzaXplLWRldGVjdG9yIHdpdGggaXRzICdzY3JvbGwnIHN0cmF0ZWd5XG4gICAqICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnOiBVc2UgaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvciB3aXRoIGl0cyAnb2JqZWN0JyBzdHJhdGVneSAoZGVwcmVjYXRlZClcbiAgICogJ3dpbmRvdyc6IE9ubHkgY2hlY2sgaWYgdGhlIHdob2xlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkL2NoYW5nZWQgb3JpZW50YXRpb24gYnkgdXNpbmcgYW5ndWxhcidzIGJ1aWx0LWluIEhvc3RMaXN0ZW5lclxuICAgKi9cbiAgQElucHV0KCdlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uJykgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3k6ICcnIHwgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yJyB8ICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvci1vYmplY3QnIHwgJ3dpbmRvdyc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbGxpcHNpcy1jbGljay1tb3JlIGh0bWwgYXR0cmlidXRlXG4gICAqICBJZiBhbnl0aGluZyBpcyBwYXNzZWQsIHRoZSBlbGxpcHNpc0NoYXJhY3RlcnMgd2lsbCBiZVxuICAgKiAgd3JhcHBlZCBpbiA8YT48L2E+IHRhZ3MgYW5kIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZVxuICAgKiAgcGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxpbmtcbiAgICovXG4gIEBPdXRwdXQoJ2VsbGlwc2lzLWNsaWNrLW1vcmUnKSBtb3JlQ2xpY2tFbWl0dGVyOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCB0byBxdWlja2x5IGZpbmQgdGhlIGxhcmdlc3QgbnVtYmVyIGZvclxuICAgKiB3aGljaCBgY2FsbGJhY2sobnVtYmVyKWAgc3RpbGwgcmV0dXJucyB0cnVlLlxuICAgKiBAcGFyYW0gIG1heCAgICAgIEhpZ2hlc3QgcG9zc2libGUgbnVtYmVyXG4gICAqIEBwYXJhbSAgY2FsbGJhY2sgU2hvdWxkIHJldHVybiB0cnVlIGFzIGxvbmcgYXMgdGhlIHBhc3NlZCBudW1iZXIgaXMgdmFsaWRcbiAgICogQHJldHVybiAgICAgICAgICBMYXJnZXN0IHBvc3NpYmxlIG51bWJlclxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgbnVtZXJpY0JpbmFyeVNlYXJjaChtYXg6IG51bWJlciwgY2FsbGJhY2s6IChuOiBudW1iZXIpID0+IGJvb2xlYW4pOiBudW1iZXIge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gbWF4O1xuICAgIGxldCBiZXN0ID0gLTE7XG4gICAgbGV0IG1pZDogbnVtYmVyO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgICAgbWlkID0gfn4oKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayhtaWQpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZXN0ID0gbWlkO1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZSBodG1sIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0gdW5zYWZlIHN0cmluZyBwb3RlbnRpYWxseSBjb250YWluaW5nIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgKiBAcmV0dXJuICAgICAgIGVzY2FwZWQgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBlc2NhcGVIdG1sKHVuc2FmZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodW5zYWZlID09PSB1bmRlZmluZWQgfHwgdW5zYWZlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZyh1bnNhZmUpXG4gICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RpdmUncyBjb25zdHJ1Y3RvclxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIG5nWm9uZTogTmdab25lKSB7IH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGluaXQgdmlldyBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIEluaXRpYWxpemVzIHRoZSBlbGVtZW50IGZvciBkaXNwbGF5aW5nIHRoZSBlbGxpcHNpcy5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBsZXQgdGhlIGVsbGlwc2lzIGNoYXJhY3RlcnMgZGVmYXVsdCB0byAnLi4uJzpcbiAgICBpZiAodGhpcy5lbGxpcHNpc0NoYXJhY3RlcnMgPT09ICcnKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyA9ICcuLi4nO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vcmVDbGlja0VtaXR0ZXIub2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzID0gYDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJuZ3gtZWxsaXBzaXMtbW9yZVwiPiR7dGhpcy5lbGxpcHNpc0NoYXJhY3RlcnN9PC9hPmA7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSByZWdleCByZXBsYWNlIG9uIHdvcmQgYm91bmRhcmllczpcbiAgICBpZiAoIXRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykge1xuICAgICAgdGhpcy5lbGxpcHNpc1dvcmRCb3VuZGFyaWVzID0gJyc7XG4gICAgfVxuICAgIHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9ICdbJyArIHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcy5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKS5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSArICddJztcblxuICAgIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBjb250ZW50cyBvZiB0aGUgZWxlbWVudDpcbiAgICB0aGlzLmVsZW0gPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBpZiAodGhpcy5lbGxpcHNpc0NvbnRlbnQpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gRWxsaXBzaXNEaXJlY3RpdmUuZXNjYXBlSHRtbCh0aGlzLmVsbGlwc2lzQ29udGVudCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5vcmlnaW5hbFRleHQpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gdGhpcy5lbGVtLmlubmVyVGV4dDtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSB3cmFwcGVyIGRpdiAocmVxdWlyZWQgZm9yIHJlc2l6ZSBldmVudHMgdG8gd29yayBwcm9wZXJseSk6XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW0sICdpbm5lckhUTUwnLCAnJyk7XG4gICAgdGhpcy5pbm5lckVsZW0gPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5pbm5lckVsZW0sICduZ3gtZWxsaXBzaXMtaW5uZXInKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVUZXh0KHRoaXMub3JpZ2luYWxUZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuaW5uZXJFbGVtLCB0ZXh0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbSwgdGhpcy5pbm5lckVsZW0pO1xuXG4gICAgLy8gc3RhcnQgbGlzdGVuaW5nIGZvciByZXNpemUgZXZlbnRzOlxuICAgIHRoaXMuYWRkUmVzaXplTGlzdGVuZXIodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQW5ndWxhcidzIGNoYW5nZSBsaWZlIGN5Y2xlIGhvb2suXG4gICAqIENoYW5nZSBvcmlnaW5hbCB0ZXh0IChpZiB0aGUgZWxsaXBzaXMtY29udGVudCBoYXMgYmVlbiBwYXNzZWQpXG4gICAqIGFuZCByZS1yZW5kZXJcbiAgICovXG4gIG5nT25DaGFuZ2VzKCkge1xuICAgIGlmICghdGhpcy5lbGVtXG4gICAgICB8fCB0eXBlb2YgdGhpcy5lbGxpcHNpc0NvbnRlbnQgPT09ICd1bmRlZmluZWQnXG4gICAgICB8fCB0aGlzLm9yaWdpbmFsVGV4dCA9PT0gRWxsaXBzaXNEaXJlY3RpdmUuZXNjYXBlSHRtbCh0aGlzLmVsbGlwc2lzQ29udGVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsVGV4dCA9IEVsbGlwc2lzRGlyZWN0aXZlLmVzY2FwZUh0bWwodGhpcy5lbGxpcHNpc0NvbnRlbnQpO1xuICAgIHRoaXMuYXBwbHlFbGxpcHNpcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuZ3VsYXIncyBkZXN0cm95IGxpZmUgY3ljbGUgaG9vay5cbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgYWxsIHJlc2l6ZSBsaXN0ZW5lcnNcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lNb3JlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gY2FsbCBhcHBseUVsbGlwc2lzKCkgd2hlbmV2ZXIgYSByZXNpemUgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyICh3aW5kb3cvZWxlbWVudCkgZGVwZW5kcyBvbiB0aGUgcmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kuXG4gICAqIEBwYXJhbSB0cmlnZ2VyTm93PWZhbHNlIGlmIHRydWUsIHRoZSBlbGxpcHNpcyBpcyBhcHBsaWVkIGltbWVkaWF0ZWx5XG4gICAqL1xuICBwcml2YXRlIGFkZFJlc2l6ZUxpc3RlbmVyKHRyaWdnZXJOb3cgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgKHRoaXMucmVzaXplRGV0ZWN0aW9uU3RyYXRlZ3kpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSA9ICcnO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5yZXNpemVEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgICAgY2FzZSAnd2luZG93JzpcbiAgICAgICAgdGhpcy5hcHBseU9uV2luZG93UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRyaWdnZXJOb3cpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VsZW1lbnQtcmVzaXplLWRldGVjdG9yLW9iamVjdCc6XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudFJlc2l6ZUxpc3RlbmVyKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZW9mIChjb25zb2xlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgTm8gc3VjaCBlbGxpcHNpcy1yZXNpemUtZGV0ZWN0aW9uIHN0cmF0ZWd5OiAnJHt0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5fScuIFVzaW5nICdlbGVtZW50LXJlc2l6ZS1kZXRlY3RvcicgaW5zdGVhZGBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3dpdGNoLWNhc2UtZmFsbC10aHJvdWdoXG4gICAgICBjYXNlICdlbGVtZW50LXJlc2l6ZS1kZXRlY3Rvcic6XG4gICAgICBjYXNlICcnOlxuICAgICAgICB0aGlzLmFkZEVsZW1lbnRSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCd3aW5kb3c6cmVzaXplJywgWyckZXZlbnQnXSkgb25SZXNpemUoZXZlbnQ6IEV2ZW50KSB7XG4gICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUpIHtcbiAgICAgICAgdGhpcy5hcHBseUVsbGlwc2lzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGNhbGwgYXBwbHlFbGxpcHNpcygpIHdoZW5ldmVyIHRoZSBlbGVtZW50XG4gICAqIGhhcyBiZWVuIHJlc2l6ZWQuXG4gICAqIEBwYXJhbSBzY3JvbGxTdHJhdGVneT10cnVlIFVzZSB0aGUgZGVmYXVsdCBlbGVtZW50UmVzaXplRGV0ZWN0b3IncyAtIHN0cmF0ZWd5IC0gcy4gaHR0cHM6Ly9naXRodWIuY29tL3duci9lbGVtZW50LXJlc2l6ZS1kZXRlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBhZGRFbGVtZW50UmVzaXplTGlzdGVuZXIoc2Nyb2xsU3RyYXRlZ3kgPSB0cnVlKSB7XG4gICAgaWYgKCFFbGxpcHNpc0RpcmVjdGl2ZS5lbGVtZW50UmVzaXplRGV0ZWN0b3IpIHtcbiAgICAgIGNvbnN0IG1ha2VyOiBhbnkgPSBlbGVtZW50UmVzaXplRGV0ZWN0b3JNYWtlcjtcbiAgICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciA9IG1ha2VyKHsgc3RyYXRlZ3k6IHNjcm9sbFN0cmF0ZWd5ID8gJ3Njcm9sbCcgOiAnb2JqZWN0JyB9KTtcbiAgICB9XG5cblxuICAgIGxldCBjYWxsZWRBc3luY2hyb25vdXNseSA9IGZhbHNlO1xuICAgIEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3Rvci5saXN0ZW5Ubyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgKCkgPT4ge1xuICAgICAgaWYgKCFjYWxsZWRBc3luY2hyb25vdXNseSkge1xuICAgICAgICAvLyBlbGVtZW50UmVzaXplRGV0ZWN0b3IgZmlyZXMgdGhlIGV2ZW50IGRpcmVjdGx5IGFmdGVyIHJlLWF0dGFjaGluZyB0aGUgbGlzdGVuZXJcbiAgICAgICAgLy8gLT4gZGlzY2FyZCB0aGF0IGZpcnN0IGV2ZW50OlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGx5RWxsaXBzaXMoKTtcbiAgICB9KTtcbiAgICBjYWxsZWRBc3luY2hyb25vdXNseSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGFueSByZXNpemUgZXZlbnQuXG4gICAqL1xuICBwcml2YXRlIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZURldGVjdGlvblN0cmF0ZWd5ICE9PSAnd2luZG93Jykge1xuICAgICAgaWYgKEVsbGlwc2lzRGlyZWN0aXZlLmVsZW1lbnRSZXNpemVEZXRlY3RvciAmJiB0aGlzLmVsZW0pIHtcbiAgICAgICAgRWxsaXBzaXNEaXJlY3RpdmUuZWxlbWVudFJlc2l6ZURldGVjdG9yLnJlbW92ZUFsbExpc3RlbmVycyh0aGlzLmVsZW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5T25XaW5kb3dSZXNpemUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW5hbCB0ZXh0J3MgdHJ1bmNhdGVkIHZlcnNpb24uIElmIHRoZSB0ZXh0IHJlYWxseSBuZWVkZWQgdG9cbiAgICogYmUgdHJ1bmNhdGVkLCB0aGlzLmVsbGlwc2lzQ2hhcmFjdGVycyB3aWxsIGJlIGFwcGVuZGVkLlxuICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgdGV4dCBtYXkgaGF2ZVxuICAgKiBAcmV0dXJuIHN0cmluZyAgICAgICB0aGUgdHJ1bmNhdGVkIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRUcnVuY2F0ZWRUZXh0KG1heDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMub3JpZ2luYWxUZXh0IHx8IHRoaXMub3JpZ2luYWxUZXh0Lmxlbmd0aCA8PSBtYXgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsVGV4dDtcbiAgICB9XG5cbiAgICBjb25zdCB0cnVuY2F0ZWRUZXh0ID0gdGhpcy5vcmlnaW5hbFRleHQuc3Vic3RyKDAsIG1heCk7XG4gICAgaWYgKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcyA9PT0gJ1tdJyB8fCB0aGlzLm9yaWdpbmFsVGV4dC5jaGFyQXQobWF4KS5tYXRjaCh0aGlzLmVsbGlwc2lzV29yZEJvdW5kYXJpZXMpKSB7XG4gICAgICByZXR1cm4gdHJ1bmNhdGVkVGV4dCArIHRoaXMuZWxsaXBzaXNDaGFyYWN0ZXJzO1xuICAgIH1cblxuICAgIGxldCBpID0gbWF4IC0gMTtcbiAgICB3aGlsZSAoaSA+IDAgJiYgIXRydW5jYXRlZFRleHQuY2hhckF0KGkpLm1hdGNoKHRoaXMuZWxsaXBzaXNXb3JkQm91bmRhcmllcykpIHtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIHRydW5jYXRlZFRleHQuc3Vic3RyKDAsIGkpICsgdGhpcy5lbGxpcHNpc0NoYXJhY3RlcnM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cnVuY2F0ZWQgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlubmVyIGRpdlxuICAgKiBAcGFyYW0gbWF4IHRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgdGV4dCBtYXkgaGF2ZVxuICAgKiBAcGFyYW0gYWRkTW9yZUxpc3RlbmVyPWZhbHNlIGxpc3RlbiBmb3IgY2xpY2sgb24gdGhlIGVsbGlwc2lzQ2hhcmFjdGVycyBpZiB0aGUgdGV4dCBoYXMgYmVlbiB0cnVuY2F0ZWRcbiAgICovXG4gIHByaXZhdGUgdHJ1bmNhdGVUZXh0KG1heDogbnVtYmVyLCBhZGRNb3JlTGlzdGVuZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLmdldFRydW5jYXRlZFRleHQobWF4KTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuaW5uZXJFbGVtLCAnaW5uZXJIVE1MJywgdGV4dCk7XG5cbiAgICBpZiAoIWFkZE1vcmVMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgbW9yZSBjbGljayBsaXN0ZW5lcjpcbiAgICBpZiAodGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZGVzdHJveU1vcmVDbGlja0xpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHRleHQgaGFzIGJlZW4gdHJ1bmNhdGVkLCBhZGQgYSBtb3JlIGNsaWNrIGxpc3RlbmVyOlxuICAgIGlmICh0ZXh0ICE9PSB0aGlzLm9yaWdpbmFsVGV4dCkge1xuICAgICAgdGhpcy5kZXN0cm95TW9yZUNsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmlubmVyRWxlbSwgJ2NsaWNrJywgKGU6IGFueSkgPT4ge1xuICAgICAgICBpZiAoIWUudGFyZ2V0IHx8IGUudGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ25neC1lbGxpcHNpcy1tb3JlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubW9yZUNsaWNrRW1pdHRlci5lbWl0KGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgZWxsaXBzaXMgaW4gdGhlIGlubmVyIGRpdiBpZiB0aGUgdGV4dCB3b3VsZCBleGNlZWQgdGhlIGJvdW5kYXJpZXNcbiAgICovXG4gIHByaXZhdGUgYXBwbHlFbGxpcHNpcygpIHtcbiAgICAvLyBSZW1vdmUgdGhlIHJlc2l6ZSBsaXN0ZW5lciBhcyBjaGFuZ2luZyB0aGUgY29udGFpbmVkIHRleHQgd291bGQgdHJpZ2dlciBldmVudHM6XG4gICAgdGhpcy5yZW1vdmVSZXNpemVMaXN0ZW5lcigpO1xuXG4gICAgLy8gRmluZCB0aGUgYmVzdCBsZW5ndGggYnkgdHJpYWwgYW5kIGVycm9yOlxuICAgIGNvbnN0IG1heExlbmd0aCA9IEVsbGlwc2lzRGlyZWN0aXZlLm51bWVyaWNCaW5hcnlTZWFyY2godGhpcy5vcmlnaW5hbFRleHQubGVuZ3RoLCBjdXJMZW5ndGggPT4ge1xuICAgICAgdGhpcy50cnVuY2F0ZVRleHQoY3VyTGVuZ3RoKTtcbiAgICAgIHJldHVybiAhdGhpcy5pc092ZXJmbG93aW5nO1xuICAgIH0pO1xuXG4gICAgLy8gQXBwbHkgdGhlIGJlc3QgbGVuZ3RoOlxuICAgIHRoaXMudHJ1bmNhdGVUZXh0KG1heExlbmd0aCwgKHRoaXMubW9yZUNsaWNrRW1pdHRlci5vYnNlcnZlcnMubGVuZ3RoID4gMCkpO1xuXG4gICAgLy8gUmUtYXR0YWNoIHRoZSByZXNpemUgbGlzdGVuZXI6XG4gICAgdGhpcy5hZGRSZXNpemVMaXN0ZW5lcigpO1xuICB9XG5cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgdGV4dCBpcyBleGNlZWRpbmcgdGhlIGVsZW1lbnQncyBib3VuZGFyaWVzIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgaXNPdmVyZmxvd2luZygpOiBib29sZWFuIHtcbiAgICAvLyBFbmZvcmNlIGhpZGRlbiBvdmVyZmxvdyAocmVxdWlyZWQgdG8gY29tcGFyZSBjbGllbnQgd2lkdGgvaGVpZ2h0IHdpdGggc2Nyb2xsIHdpZHRoL2hlaWdodClcbiAgICBjb25zdCBjdXJyZW50T3ZlcmZsb3cgPSB0aGlzLmVsZW0uc3R5bGUub3ZlcmZsb3c7XG4gICAgaWYgKCFjdXJyZW50T3ZlcmZsb3cgfHwgY3VycmVudE92ZXJmbG93ID09PSAndmlzaWJsZScpIHtcbiAgICAgIHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIGNvbnN0IGlzT3ZlcmZsb3dpbmcgPSB0aGlzLmVsZW0uY2xpZW50V2lkdGggPCB0aGlzLmVsZW0uc2Nyb2xsV2lkdGggLSAxIHx8IHRoaXMuZWxlbS5jbGllbnRIZWlnaHQgPCB0aGlzLmVsZW0uc2Nyb2xsSGVpZ2h0IC0gMTtcblxuICAgIC8vIFJlc2V0IG92ZXJmbG93IHRvIHRoZSBvcmlnaW5hbCBjb25maWd1cmF0aW9uOlxuICAgIHRoaXMuZWxlbS5zdHlsZS5vdmVyZmxvdyA9IGN1cnJlbnRPdmVyZmxvdztcblxuICAgIHJldHVybiBpc092ZXJmbG93aW5nO1xuICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRWxsaXBzaXNEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvZWxsaXBzaXMuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtFbGxpcHNpc0RpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtFbGxpcHNpc0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRWxsaXBzaXNNb2R1bGUgeyB9XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiRGlyZWN0aXZlIiwiRWxlbWVudFJlZiIsIlJlbmRlcmVyMiIsIk5nWm9uZSIsIklucHV0IiwiT3V0cHV0IiwiSG9zdExpc3RlbmVyIiwiTmdNb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7OztBQW1CQTs7OztRQTZIRSwyQkFBMkIsVUFBc0IsRUFBVSxRQUFtQixFQUFVLE1BQWM7WUFBM0UsZUFBVSxHQUFWLFVBQVUsQ0FBWTtZQUFVLGFBQVEsR0FBUixRQUFRLENBQVc7WUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFROzs7O1lBbEc5Rix3QkFBbUIsR0FBRyxLQUFLLENBQUM7Ozs7OztZQXFCVCxvQkFBZSxHQUFXLElBQUksQ0FBQzs7Ozs7OztZ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